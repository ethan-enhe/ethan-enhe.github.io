---
layout:     post
title:      cf-edu-round-47解题记录
subtitle:   水题翻车
date:       2020-07-08
author:     ethan-zhou
header-img: img/home-bg-m42.jpg
catalog: true
tags:
    - c++
    - 算法
    - 题解
---
## T1
直接按照题目要求模拟，复杂度$$O(M+N)$$
**代码**
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int NR=1005;
int n,m;
int a[NR],b[NR];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	for(int i=1;i<=m;i++)scanf("%d",b+i);
	int j=1;
	for(int i=1;(j<=n)&&(i<=n);i++)
		if(a[i]<=b[j])j++;
	printf("%d",j-1);
	return 0;
}

```
## T2
将这个字符串以2为界分为几部分

$$（部分1）2（部分二）2\cdots2（部分n）$$

题目所等效的条件为：
在这个字符串中，2是固定的，1可以随意移动，0可以在其所在的部分任意移动。
所以简单的贪心一下，把每个部分的0移到这个部分的最前头，把每个部分的1集中起来移到第一个2的前头即可，所以最终的字符串是这样的：

$$00\cdots011\cdots1 +（一个以2开头，由0和2构成的字符串）$$

**代码：（奇丑无比）**
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
char s[100005];
int n0,n1;
int main(){
	scanf("%s",s+1);
	int len=strlen(s+1);
	for(int i=1;(s[i]!='2')&&(i<=len);i++)n0+=s[i]=='0';
	for(int i=1;(i<=len);i++)n1+=s[i]=='1';
	for(int i=1;i<=n0;i++)putchar('0');
	for(int i=1;i<=n1;i++)putchar('1');
	bool f=0;
	for(int i=1;(i<=len);i++){
		f|=s[i]=='2';
		if(f && s[i]!='1')putchar(s[i]);
	}
	return 0;
}

```
## T3
暴力推式子，每次操作对总合的贡献：

$$delta_i=x\times n+d\times(\sum_{j=1}^{i-1} j+\sum_{j=1}^{n-i} j)\c$$
<!--stackedit_data:
eyJoaXN0b3J5IjpbMzQxMzkzNDc3LDExMzY5NzMzNzIsLTk2Mj
I2NTQyMyw5ODU4ODIyNDddfQ==
-->