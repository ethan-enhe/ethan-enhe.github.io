---
layout:     post
title:      cf-edu-round-48解题记录
subtitle:   有点难
date:       2020-07-10
author:     ethan-zhou
header-img: img/post-bg-debug.png
catalog: true
tags:
    - c++
    - 算法
    - 题解
---
## T1
直接模拟

**代码：**
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m;
int cp=0,tmp;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&tmp);
		cp+=tmp;
		printf("%d ",cp/m);
		cp%=m;
	}

	return 0;
}
```

## T2
本以为这题怎么也得写个 kmp，结果发现字符串长度都小于 1000，于是直接暴力匹配，记录字串从母串的哪一位开始能匹配的上，最后来个前缀和即可。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int NR=1005;
int n,m,q;
char mo[NR],so[NR];
int sum[NR];
int main(){
	scanf("%d%d%d",&n,&m,&q);
	scanf("%s%s",mo+1,so+1);
	for(int i=1;i<=n-m+1;i++){
		sum[i]=1;
		for(int j=0;j<m;j++)
			if(mo[i+j]!=so[j+1]){
				sum[i]=0;
				break;
			}
		sum[i]+=sum[i-1];
	}
	while(q--){
		int l,r;
		scanf("%d%d",&l,&r);
		if(r-l+1<m)printf("0\n");
		else printf("%d\n",sum[r-m+1]-sum[l-1]);
	}
	return 0;
}
```
## T3
这道题还不太好想，首先考虑他为什么只给两行？显然不是为了方便搜索，而是方便 dp 或者分类讨论的，想了想 dp，不太好保证没有后效性，于是只能分类讨论了。

首先，既然经过了每一个单元格，这个路径就必定先走 S 形，后走 U 形状，如图所示：~~读者不难自证~~
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMjI3ODQwNjldfQ==
-->