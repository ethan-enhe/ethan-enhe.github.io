---
layout:     post
title:      【题解】[APIO2020]T1粉刷墙壁
subtitle:   第一次参加apio
date:       2020-08-18
author:     ethan-zhou
header-img: img/home-bg-m42.jpg
catalog: true
tags:
    - 题解
    - 算法
    - c++
---

> 注：本题解详细讲解了各部分分的得法以及对于正解的启发

## 问题转化

理解题意之后我们不难发现，只要我们能算出是否有以 i 块墙壁开始，刷 M 块墙的合法请求，那么这就转化成了一个区间覆盖问题。

> 比如：
> 样例1中，x=1，y=0 是一个合法请求，那么 [0,M-1] 就是一个合法区间（即：一次请求就可以覆盖这个区间）

找出这些区间之后，就可以做一个简单的贪心了，贪心代码如下：
```cpp
/* 
 * canpaint[i]表示有没有从第i块开始的合法区间
 * lastr表示目前匹配到的右端点
 * newl表示下一个合法区间的左端点
 */
int lastr=-1,newl=0,ans=0;
while(lastr<N-1){
	int mxl=-1;
	while(newl<=lastr+1 && newl<N){
		if(canpaint[newl])mxl=newl;
		newl++;
	}
	if(mxl==-1)return -1;
	lastr=mxl+M-1;
	ans++;
}
```

## 预处理

但是，我们做完了吗？并没有。这题的不好搞的地方在于 canpaint 数组的预处理。

### 28分

$$NM^2$$的暴力，枚举每个 x 和 y，并暴力匹配，能得到第二组和第三组的分数，代码过于简单，略。

### 51分
写一个dp，令 f[i][j] 表示从第 j 个商家，第i块墙壁开始匹配，最多能刷几块墙，则其转移如下

$$
f[i][j]=\left\{
\begin{aligned} 
&0&（第j个商家不能刷第i个墙）\\
&f[i+1][(j+1)mod M]&（第j个商家能刷第i个墙）
\end{aligned}  \right. 
$$
但是 NM 的空间显然是存不下的，所以你需要将i那一维滚动掉，最终的时间。

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTA5MDkzODAxOCw2NTMwMDc1OTUsNDk0MT
c5NjEwLDE5NDU4NjUwMjMsODA4MTg0MDQyXX0=
-->