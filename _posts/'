---
layout:     post
title:      NOI2016题解
subtitle:   题型新颖
date:       2022-05-29
author:     ethan-zhou
header-img: img/post-bg-YesOrNo.jpg
catalog: true
tags:
    - 线段树
    - dp
    - 斜率优化
    - 提交答案
---

## T1 线段

### 题意

$n$ 个区间，从其中选出 $m$ 个，使得全部 $m$ 个线段交非空。求这 m 个线段长度极差的最小值。

$$
m\le n \le 5\times 10^5
$$

### 思路

线段按长度排序，随后双指针。开线段树表示每个位置被覆盖次数，最大值大于 $m$ 时合法。

## T2 国王饮水记

(见之前题解)

## T3 旷野大计算

### 题意：略

![函数](https://cdn.luogu.com.cn/upload/pic/2394.png)

一些关于 $S(x)$ 的性质（注意 S 函数非常有用）：
- $S^\prime(x)=\frac{e^{-x}}{(1+e^{-x})^2}$
- $\lim_{x\to 0}S(x)=\frac 12$
- $\lim_{x\to \infin}S(x)=1$
- $\lim_{x\to -\infin}S(x)=0$

后文中，我们定义 $\infin$ 为一个超级大的数，具体实现时一般用 2 的多少次幂，方便用左移右移搞出来。

### Task 1,2：略

### Task 3

![](https://pic.imgdb.cn/item/629347e209475431295b22d2.jpg)

要求节点数量不超过 6，第一个要动脑筋的地方。

---

注意到输出不是线性的，因此不用 s 是不可能做到的。然后，我们定义

$$
P(x)=S(x\times \infin)=\left\{
\begin{aligned}
1   &\qquad &x>0 \\
0.5 &&x=0\\
0   &&x<0
\end{aligned}
\right.
$$

这个 $P$ 函数之后也非常有用，在这里直接 $2P(x)-1$ 即可。

### Task 4

![](https://pic.imgdb.cn/item/62941d94094754312953c647.jpg)

14 个节点满分。

#### 6 分

这个 task 满分比较难，在此先使用上问结果乘以 a 得到 6 分。

#### 10 分

（没想出来，只能揣测下出题人思路）

首先，绝对值也不是线性函数，必定会用到 S 函数。然后考虑我们用 S 搞出个什么函数之后我们可以通过平移和线性变换变成绝对值函数。

发现这个函数必然然是一个两段的折线，就是说，存在某个 $x_0$，使得这一函数在 $x<x_0$ 的斜率不等于 $x>x_0$ 时的斜率。

这样，我们可以先把 $x_0$ 平移到 0，然后整体加上某个一次函数，使其变成一个偶函数。最后再整体乘上一个常数，使得其斜率变成 $\pm 1$。

当然，这里也有很多巧合的因素，因为在整体加一次函数和整体乘常数的时候，这个一次函数的斜率和常数都必须非常整，才可以在有限次数中用左移右移凑出来。

考虑如下函数（该函数 0 点的函数值比较麻烦，实现的时候先把输入加上一个 EPS 再做）：

$$
f(x)=S(P(x)\times \infin+\frac x {\infin})=
\left\{
    \begin{aligned}
    1&&x>0\cr
    0.5+\frac x {4\infin}&&x<0
    \end{aligned}
\right.
$$

![](https://pic.imgdb.cn/item/6294232209475431295b9e44.jpg)

这函数是这样的

然而这个函数在并不是一个折线，两个一次函数在 $x=0$ 除没有连起来。然而不要紧，我们可以在最后通过 $P$ 函数把正半轴的函数值全都加上某个数，因此作如下变换：

$$
g(x)=(0.5-f(x))\times 8\infin=
\left\{
    \begin{aligned}
    -0.5\times 8\infin&&x>0\cr
    -2x &&x<0
    \end{aligned}
\right.
$$

至于为啥把 $x<0$ 弄成 -2x，这是因为后面直接把这个玩意 $+x$，这样正负部分的斜率都对了。然后再使用 $P$ 函数把正半轴的截距搞到 0 即可。实现时注意不要重复计算，精细实现即可满分。

### Task 5

![](https://pic.imgdb.cn/item/62942866094754312962cc1a.jpg)

要求95次操作。

模拟即可，需要精细实现，不该加的时候不要乱加。

### Task 6

![](https://pic.imgdb.cn/item/6294344d094754312972f909.jpg)

要求190次操作。

从高向低枚举每一位，输出 $P(x-2^i+0.5)$，然后再 $x\gets x- P(x-2^i+0.5)\times 2^i$。

注意到计算 P 的过程中，多次把 x 左移。所以还不如一开始就把 x 左移。

需要精细实现：

```cpp
data x = read();
x = x << 30;
for (ll i = 31; ~i; i--) {
    //减去对应位，判断正负
    data res = i ? s(x + (1e6 - powl(2, i + 30))) : x >> 30;
    prt(res);
    //删除当前位置
    if (i) x = x + (-(res << (i + 30)));
}
```

### Task 7


要求600多次操作。

在前两问基础上实现一个异或函数即可。

注意到 $x\oplus y=x+y-2[x+y>1]=x+y-2P(x+y-1.5)$。

### Task 8

要求 7 次操作。

一个思路是用二进制把 $\frac 1{10}$ 凑出来，然而七次操作精度太差，只能精确到三位小数。

一个大胆的想法：$S$ 函数的斜率均匀变化，可否找到某处斜率为 $\frac 1{10}$，然后把这段放大放大再放大，用来拟合 $y=\frac x{10}$？

答案是肯定的，一开始你的想法是二分出这个位置，然而：

![](https://pic.imgdb.cn/item/62943b3209475431297c83d0.jpg)

精度不够。。

随后你求个导：$S^\prime(x)=\frac{e^{-x}}{(1+e^{-x})^2}$，然后算出来这个位置的精确值：$\ln(\sqrt{15}+4)$ 用 C++ 算了一下，输出出来，依然是一个 wa。。

根据题解的说法，在场上的时候需要用计算器算出小数点后几十位，然后拿程序输出出来才行，于是（第一个数是位置，第二个数是那个位置的 $S$ 函数值）：

```cpp
string magic = "2.06343706889556054672728117262013187145659144988339249983603269276590284284740991";
data x = (read() >> 100) + magic;
x = S(x) + "-0.887298334620741688517926539978239961083292170529159082658757376611348309193697903351";
prt(x << 100);
```

就过了。。

### Task 9

要求 3000 次操作。

自然的想法是插入或冒泡排序。因此，我们需要设计一个模块，输入两个数，这个模块把这两个数按大小顺序排好输出出来。

只要知道了 $\max(x,y)$，也就是第二个数，那么第一个数一减就出来了。

因为 $\max(x,y)=x+\max(y-x,0)$，我们需要设计一个模块，把某个数和 0 取 max。

发现 $y=\max(x,0)$ 的函数竟跟刚刚算绝对值的函数有几分相似，这里再回顾一下：


