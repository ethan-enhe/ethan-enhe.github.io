<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog E</title>
    <description>路漫漫其修远兮，吾将上下而求索。</description>
    <link>http://blog-e.tk/</link>
    <atom:link href="http://blog-e.tk/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 20 Jun 2021 11:25:45 +0800</pubDate>
    <lastBuildDate>Sun, 20 Jun 2021 11:25:45 +0800</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>斯特林数学习笔记</title>
        <description>&lt;h2 id=&quot;第一类斯特林数&quot;&gt;第一类斯特林数&lt;/h2&gt;
&lt;h3 id=&quot;几何意义&quot;&gt;几何意义&lt;/h3&gt;
&lt;p&gt;把 n 各不同的数放进为 k 个环的方案数，用 $\begin{bmatrix}n\cr k\end{bmatrix}$ 表示。&lt;/p&gt;

&lt;h3 id=&quot;代数意义&quot;&gt;代数意义&lt;/h3&gt;

\[\begin{aligned}
x^{\overline{n}}&amp;amp;=\sum_{i=1}^n \begin{bmatrix}n\cr i\end{bmatrix}x^i\cr
x^{\underline{n}}&amp;amp;=\sum_{i=1}^n (-1)^{n-i}\begin{bmatrix}n\cr i\end{bmatrix}x^i
\end{aligned}\]

&lt;h3 id=&quot;计算方式&quot;&gt;计算方式&lt;/h3&gt;

&lt;p&gt;$O(nk)$ 递推：&lt;/p&gt;

\[\begin{bmatrix}n\cr k\end{bmatrix}=(n-1)\begin{bmatrix}n-1\cr k\end{bmatrix}+\begin{bmatrix}n-1\cr k-1\end{bmatrix}\]

&lt;h2 id=&quot;第二类斯特林数&quot;&gt;第二类斯特林数&lt;/h2&gt;

&lt;h3 id=&quot;组合意义&quot;&gt;组合意义&lt;/h3&gt;
&lt;p&gt;把 n 各不同的数放进为 k 个非空集合的方案数，用 $\begin{Bmatrix}n\cr k\end{Bmatrix}$ 表示。&lt;/p&gt;

&lt;h3 id=&quot;代数意义-1&quot;&gt;代数意义&lt;/h3&gt;

\[\begin{aligned}i^k&amp;amp;=&amp;amp;&amp;amp;\sum_{j=1}^k i^{\underline{j}}\begin{Bmatrix}k\cr j\end{Bmatrix}\cr &amp;amp;=&amp;amp;&amp;amp;\sum_{j=1}^k \binom i j j! \begin{Bmatrix}k\cr j\end{Bmatrix}\cr \end{aligned}\]

&lt;h3 id=&quot;计算方式-1&quot;&gt;计算方式&lt;/h3&gt;

&lt;p&gt;$O(nk)$ 递推：&lt;/p&gt;

\[\begin{Bmatrix}n\cr k\end{Bmatrix}=k\begin{Bmatrix}n-1\cr k\end{Bmatrix}+\begin{Bmatrix}n-1\cr k-1\end{Bmatrix}\]

&lt;p&gt;$O(k \log n)$ 容斥：&lt;/p&gt;

\[\begin{Bmatrix}n\cr k\end{Bmatrix}=\frac 1 {k!}\sum_{i=0}^k (-1)^i \binom k i (k-i)^n\]

&lt;h2 id=&quot;斯特林反演&quot;&gt;斯特林反演&lt;/h2&gt;

&lt;h3 id=&quot;哪些题可能是斯特林反演&quot;&gt;哪些题可能是斯特林反演&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;求和 $\sum_{i=1}^n (\cdots) i^k$&lt;/li&gt;
  &lt;li&gt;n 超级大，但 $k^2$ 能过&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;步骤&quot;&gt;步骤&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;反演&lt;/li&gt;
&lt;/ul&gt;

\[\begin{aligned}i^k&amp;amp;=&amp;amp;&amp;amp;\sum_{j=1}^k i^{\underline{j}}\begin{Bmatrix}k\cr j\end{Bmatrix}\cr &amp;amp;=&amp;amp;&amp;amp;\sum_{j=1}^k \binom i j j! \begin{Bmatrix}k\cr j\end{Bmatrix}\cr \end{aligned}\]

&lt;ul&gt;
  &lt;li&gt;换序求和&lt;/li&gt;
&lt;/ul&gt;

\[=\sum_{j=1}^k j! \begin{Bmatrix}k\cr j\end{Bmatrix}\sum_{i=1}^n \binom i j (\cdots)\]

&lt;ul&gt;
  &lt;li&gt;化简后面一部分：
    &lt;ul&gt;
      &lt;li&gt;重组组合数，尽量多凑成与 i 无关的形式，比如：&lt;/li&gt;
    &lt;/ul&gt;

\[\sum_{i=1}^n \binom i j \binom n i=\binom n j \sum_{i=1}^n \binom {n-j} {i-j}\]

    &lt;ul&gt;
      &lt;li&gt;利用组合意义求和，比如：&lt;/li&gt;
    &lt;/ul&gt;

\[\sum_{i=1}^n \binom i j=\binom {n+1}{j+1}\]
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 18 Jun 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/06/18/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/06/18/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>组合</category>
        
        <category>笔记</category>
        
        
      </item>
    
      <item>
        <title>斜率优化学习笔记</title>
        <description>&lt;h2 id=&quot;问题形式&quot;&gt;问题形式&lt;/h2&gt;

&lt;p&gt;用来优化一类 dp，其转移方程满足：&lt;/p&gt;

\[dp_i=f_i(\max_{j&amp;lt;i}(k_j\times x_i+b_j))\]

&lt;p&gt;（式子中取 min 也可，与 max 类似，不再赘述）&lt;/p&gt;

&lt;p&gt;其中 $k_j,b_j$ 是只与 j 相关的数，$x_i$ 是只与 i 相关的数，$f_i$ 是只与 i 有关的函数。&lt;/p&gt;

&lt;p&gt;斜率优化就是优化的求 $\max_{j&amp;lt;i}(k_j\times x_i+b_j)$ 的过程。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;两种理解&quot;&gt;两种理解&lt;/h2&gt;

&lt;h3 id=&quot;截距法&quot;&gt;截距法&lt;/h3&gt;

&lt;p&gt;将每个 j 对应到平面上一点 $(k_j,b_j)$，然后用一个斜率为 $-x_i$ 的直线从上往下移动，直到碰到一个点，此时 y 轴截距即为答案。&lt;/p&gt;

&lt;h3 id=&quot;函数法&quot;&gt;函数法&lt;/h3&gt;

&lt;p&gt;将 $g_j(x)=k_j\times x+b_j$ 看成只与 j 有关的的&lt;strong&gt;一次函数&lt;/strong&gt;，原式等价于在 $x=x_i$ 处所有函数的极值。&lt;/p&gt;

&lt;p&gt;感觉这个方法比较好理解，后文都以此方法为例。&lt;/p&gt;

&lt;h2 id=&quot;如何维护&quot;&gt;如何维护&lt;/h2&gt;

&lt;p&gt;因为是将所有一次函数取 max，所以所有可能成为答案的直线必定是一个&lt;strong&gt;斜率递增&lt;/strong&gt;的&lt;strong&gt;下凸壳&lt;/strong&gt;，在不同情况下，可采用不同的方法维护凸壳上的函数。&lt;/p&gt;

&lt;h3 id=&quot;k_ix_i-都随-i-递增单调队列&quot;&gt;$k_i,x_i$ 都随 i 递增——单调队列&lt;/h3&gt;

&lt;p&gt;插入直线时，不断弹出队尾，直到队尾的直线在凸壳上没有被新直线&lt;strong&gt;完全覆盖&lt;/strong&gt;，再将新队列加入队尾。&lt;/p&gt;

&lt;p&gt;查询时，不断弹出队首，直到队列前两条直线的交点大于 $x_i$，此时队首的函数即为答案。&lt;/p&gt;

&lt;h3 id=&quot;k_i-随-i-递增x_i-不随-i-递增单调队列二分&quot;&gt;$k_i$ 随 i 递增，$x_i$ 不随 i 递增——单调队列+二分&lt;/h3&gt;

&lt;p&gt;插入方法同上，查询时不能直接弹队首了，应该在队列上二分，找到凸壳上包含 $x_i$ 的一段直线。&lt;/p&gt;

&lt;h3 id=&quot;k_ix_i-都不随-i-递增李超树&quot;&gt;$k_i,x_i$ 都不随 i 递增——李超树&lt;/h3&gt;

&lt;p&gt;可以用李超树维护这个凸壳，后文有介绍，（听说也可以用平衡树，CDQ 分治维护，但不太好写）。&lt;/p&gt;

&lt;h2 id=&quot;简单快捷李超树&quot;&gt;简单快捷李超树&lt;/h2&gt;

&lt;p&gt;李超树是一个支持以 $O(\log n)$ 复杂度插入一条直线（如果是插入线段，则复杂度为 $O(\log^2 n)$），并以同样复杂度查询某一个位置的最大值的线段树。&lt;/p&gt;

&lt;h3 id=&quot;插入操作&quot;&gt;插入操作&lt;/h3&gt;

&lt;p&gt;李超树的每个节点上维护的是：在当前区间的&lt;strong&gt;中点&lt;/strong&gt;，函数值最大的函数（下称最优函数），可以如下更新：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;考虑新插入的函数，与区间的原最优函数：&lt;/li&gt;
  &lt;li&gt;将两者中较&lt;strong&gt;优&lt;/strong&gt;的存到这个节点上&lt;/li&gt;
  &lt;li&gt;用两者中较&lt;strong&gt;劣&lt;/strong&gt;的更新子区间：
    &lt;ul&gt;
      &lt;li&gt;如果较劣的函数比较优的函数斜率&lt;strong&gt;大&lt;/strong&gt;，则用其递归更新&lt;strong&gt;右子区间&lt;/strong&gt;（如下面图 1 所示，这条线段仍然有可能在右子区间里成为最优函数）&lt;/li&gt;
      &lt;li&gt;否则用其递归更新&lt;strong&gt;左子区间&lt;/strong&gt;（同理）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://pic.imgdb.cn/item/60bf0f33844ef46bb24a61d4.jpg&quot; alt=&quot;图 1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;查询操作&quot;&gt;查询操作&lt;/h3&gt;

&lt;p&gt;求 x 处最大的函数值，只需将线段树上 x 所在区间，以及它祖先上所有区间的最优函数，在x处的函数值取 max 即可。&lt;/p&gt;

&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;

&lt;h3 id=&quot;acwing-301-任务安排2&quot;&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/303/&quot;&gt;AcWing 301. 任务安排2&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;费用提前计算，记 $t_i,c_i$ 的前缀和为 $st_i,sc_i$，列出转移方程：&lt;/p&gt;

\[dp_i=\min_{j&amp;lt;i}(\underbrace{-sc_j}_{k_j}\times \underbrace{st_i}_{x_i}+\underbrace{dp_j+s\times(sc_n-sc_j)}_{b_j})+st_i*sc_i\]

&lt;p&gt;其中斜率与横坐标 $-sc_j,st_i$ 都单调，只需单调队列维护即可 &lt;del&gt;但我是拿二分的代码过的&lt;/del&gt;。&lt;/p&gt;

&lt;h3 id=&quot;acwing-302-任务安排3&quot;&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/303/&quot;&gt;AcWing 302. 任务安排3&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;与上一题题意相同，区别在 $st_i$ 不单调，只需在单调队列上二分即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef pair&amp;lt;ll,ll&amp;gt; pi;
const ll INF=1e18;
const ll MXN=3e5+5;

inline long double inter(const pi &amp;amp;x,const pi &amp;amp;y){return x.fi==y.fi?(x.se&amp;gt;y.se?-INF:INF):(long double)(y.se-x.se)/(x.fi-y.fi);}

ll n,s,sc[MXN],st[MXN],dp[MXN];
pi q[MXN];ll ql=1,qr;
int main(){
	scanf(&quot;%lld%lld&quot;,&amp;amp;n,&amp;amp;s);
	for(int i=1;i&amp;lt;=n;i++){
		scanf(&quot;%lld%lld&quot;,st+i,sc+i);
		st[i]+=st[i-1],sc[i]+=sc[i-1];
	}
	q[++qr]=mp(0,s*sc[n]);
	for(int i=1;i&amp;lt;=n;i++){
		ll l=ql,r=qr;
		while(l&amp;lt;r){
			ll mid=(l+r)&amp;gt;&amp;gt;1;
			if(inter(q[mid],q[mid+1])&amp;gt;=st[i])r=mid;
			else l=mid+1;
		}
		dp[i]=q[l].fi*st[i]+q[l].se+st[i]*sc[i];
		pi curseg=mp(-sc[i],dp[i]+s*(sc[n]-sc[i]));
		while(ql&amp;lt;qr &amp;amp;&amp;amp; inter(q[qr-1],q[qr])&amp;gt;=inter(q[qr],curseg))qr--;
		q[++qr]=curseg;
	}
	printf(&quot;%lld&quot;,dp[n]);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;p3628-apio2010特别行动队&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3628&quot;&gt;P3628 [APIO2010]特别行动队&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;直接推式子，方程为：&lt;/p&gt;

\[dp_i=(a s_i^2+b s_i+c) + \max_{j&amp;lt;i}(\underbrace{-2a s_j}_{k_j}\times\underbrace{s_i}_{x_i} +\underbrace{dp_j+a s_j^2-b s_j}_{b_j})\]

&lt;p&gt;其中斜率与 x 坐标 $-2a s_i,s_i$ 都单调变化，所以单调队列维护即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef pair&amp;lt;ll,ll&amp;gt; pi;

const long double INF=1e18;
const long double EPS=1e-9;
const ll MXN=1e6+5;
ll n,a,b,c,ql=1,qr,dp[MXN];
pi q[MXN];

long double intersec(pi x,pi y){
	if(x.fi==y.fi)return y.se&amp;gt;x.se?-INF:INF;
	return (long double)(y.se-x.se)/(x.fi-y.fi);
}
int main(){
	scanf(&quot;%lld%lld%lld%lld&quot;,&amp;amp;n,&amp;amp;a,&amp;amp;b,&amp;amp;c);
	q[++qr]=mp(0,0);
	for(ll i=1,tmp,s=0;i&amp;lt;=n;i++){
		scanf(&quot;%lld&quot;,&amp;amp;tmp);s+=tmp;
		while(ql&amp;lt;qr &amp;amp;&amp;amp; intersec(q[ql],q[ql+1])+EPS&amp;lt;s)ql++;
		dp[i]=s*q[ql].fi+q[ql].se+(a*s*s+b*s+c);
		pi cseg=mp(-2*a*s,dp[i]+a*s*s-b*s);
		while(ql&amp;lt;qr &amp;amp;&amp;amp; intersec(q[qr-1],q[qr])&amp;gt;intersec(q[qr-1],cseg)+EPS)qr--;
		q[++qr]=cseg;
	}
	printf(&quot;%lld&quot;,dp[n]);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;p3648-apio2014序列分割&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3648&quot;&gt;P3648 [APIO2014]序列分割&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;发现结果与切割顺序无关，不难推出 dp 式，其中斜率与 x 坐标单调增。&lt;/p&gt;

&lt;p&gt;注意特判两条线平行的情况，返回正负无穷，至于具体返回哪个，因题而异。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef pair&amp;lt;ll,ll&amp;gt; pi;

const long double INF=1e18;
const ll MXN=1e5+5;
const ll MXK=205;

ll ql,qr;pi q[MXN];
long double inter(pi x,pi y){
	if(x.fi==y.fi)return y.se&amp;gt;x.se?-INF:-INF;
	return (long double)(y.se-x.se)/(x.fi-y.fi);
}
ll n,k,arr[MXN];
ll dp[MXK][MXN];
int main(){

	scanf(&quot;%lld%lld&quot;,&amp;amp;n,&amp;amp;k);
	for(int i=1;i&amp;lt;=n;i++){
		scanf(&quot;%lld&quot;,arr+i);
		arr[i]+=arr[i-1];
	}
	for(int i=1;i&amp;lt;=k;i++){
		q[qr=ql=1]=mp(0,0);
		for(int j=1;j&amp;lt;=n;j++){
			while(ql&amp;lt;qr &amp;amp;&amp;amp; arr[j]&amp;gt;=inter(q[ql],q[ql+1]))ql++;
			dp[i][j]=arr[j]*q[ql].fi+q[ql].se;
			pi cseg=mp(arr[j],dp[i-1][j]-arr[j]*arr[j]);
			while(ql&amp;lt;qr &amp;amp;&amp;amp; inter(q[qr-1],q[qr])&amp;gt;=inter(q[qr-1],cseg))qr--;
			q[++qr]=cseg;
		}
	}
	printf(&quot;%lld\n&quot;,dp[k][n]);
	for(int i=k,cur=n;i;i--){
		for(int j=1;j&amp;lt;cur;j++)
			if(dp[i-1][j]+arr[j]*(arr[cur]-arr[j])==dp[i][cur]){
				cur=j;
				break;
			}
		printf(&quot;%lld\n&quot;,cur);
	}
	return 0;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;p5017-noip2018-普及组-摆渡车&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P5017&quot;&gt;P5017 [NOIP2018 普及组] 摆渡车&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;dp 转移不难变成斜率优化的形式，可以线性解决。&lt;/p&gt;

&lt;p&gt;还可以进一步利用两人到达时间相差超过 $2m$ 可以当成 $2m$ 的性质，缩短时间轴。&lt;/p&gt;

&lt;p&gt;复杂度 $O(\min(nm,T))$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
typedef pair&amp;lt;ll,ll&amp;gt; pi;
const ll MXN=505;
const ll MXT=1.1e5;
const ll INF=1e18;
ll n,m,ans=INF;
ll arr[MXN],s[MXT],si[MXT],dp[MXT];
ll ql=1,qr;
pi q[MXT];
inline long double inter(const pi &amp;amp;a,const pi &amp;amp;b){return a.fi==b.fi?(a.se&amp;gt;b.se?-INF:INF):(long double)(a.se-b.se)/(b.fi-a.fi);}
int main(){
	scanf(&quot;%lld%lld&quot;,&amp;amp;n,&amp;amp;m);
	for(ll i=1;i&amp;lt;=n;i++)scanf(&quot;%lld&quot;,arr+i);
	sort(arr+1,arr+1+n);
	for(ll i=n;i;i--)arr[i]=min(m&amp;lt;&amp;lt;1,arr[i]-arr[i-1]);
	for(ll i=1;i&amp;lt;=n;i++){
		arr[i]+=arr[i-1];
		s[arr[i]]++;
		si[arr[i]]+=arr[i];
	}

	for(ll i=1;i&amp;lt;=arr[n]+m;i++){
		s[i]+=s[i-1],si[i]+=si[i-1];
		if(i&amp;gt;=m){
			pi cseg=mp(-s[i-m],dp[i-m]+si[i-m]);
			while(ql&amp;lt;qr &amp;amp;&amp;amp; inter(q[qr-1],q[qr])&amp;gt;=inter(q[qr],cseg))qr--;
			q[++qr]=cseg;
			while(ql&amp;lt;qr &amp;amp;&amp;amp; i&amp;gt;=inter(q[ql],q[ql+1]))ql++;
			dp[i]=q[ql].fi*i+q[ql].se;
		}
		dp[i]+=s[i]*i-si[i];
		if(i&amp;gt;=arr[n])ans=min(ans,dp[i]);
	}
	printf(&quot;%lld&quot;,ans);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;p4027-noi2007-货币兑换-李超树&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4027&quot;&gt;P4027 [NOI2007] 货币兑换&lt;/a&gt; （李超树）&lt;/h3&gt;

&lt;p&gt;发现最优情况下每一次买入必定把所有钱都用了，每次卖出都必定把所有金券卖了。&lt;/p&gt;

&lt;p&gt;于是不难推出转移方程为（$dp_i$ 表示第 i 天，卖币之后，买币之前，最多拥有多少钱）：&lt;/p&gt;

\[dp_i=max(dp_{i-1},\max(\underbrace{(B_i/A_i)}_{x_i}\times \underbrace{A_i dp_j/(A_j Rate_j+B_j)}_{k_j}+\underbrace{Rate_j A_i dp_j/(A_j Rate_j+B_j)}_{b_j}))\]

&lt;p&gt;发现斜率与横坐标都不一定单调，只能用李超树维护。&lt;/p&gt;

&lt;p&gt;又因为用李超树查询的横坐标是浮点数，不太好搞，可以提前将会查询到的 x 坐标离散化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码（甚短）：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define mp make_pair
#define fi first
#define se second
using namespace std;
typedef long long ll;
typedef pair&amp;lt;double,double&amp;gt; pr;
const ll MXN=1e5+5;
const ll INF=1e18;
ll n;
double arr[MXN],brr[MXN],rate[MXN],dp[MXN],pool[MXN];


struct node{ll ls,rs;pr line;}t[MXN&amp;lt;&amp;lt;2];ll rt,nodec;
inline double f(pr line,ll x){return line.fi*pool[x]+line.se;}
inline double f(pr line,double x){return line.fi*x+line.se;}
inline ll nnode(){return t[++nodec].line=mp(0,-INF),nodec;}
inline void mod(ll &amp;amp;p,ll l,ll r,pr ml){
	ll mid=(l+r)&amp;gt;&amp;gt;1;
	if(!p)p=nnode();
	if(f(ml,mid)&amp;gt;f(t[p].line,mid))swap(ml,t[p].line);
	if(l==r)return;
	ml.fi&amp;lt;t[p].line.fi?mod(t[p].ls,l,mid,ml):mod(t[p].rs,mid+1,r,ml);
}
inline double que(ll p,ll l,ll r,double qx){
	if(!p || l==r)return f(t[p].line,qx);
	ll mid=(l+r)&amp;gt;&amp;gt;1;
	return max(f(t[p].line,qx),qx&amp;gt;pool[mid]?que(t[p].rs,mid+1,r,qx):que(t[p].ls,l,mid,qx));
}
int main(){
	scanf(&quot;%lld%lf&quot;,&amp;amp;n,&amp;amp;dp[0]);
	for(int i=1;i&amp;lt;=n;i++){
		scanf(&quot;%lf%lf%lf&quot;,arr+i,brr+i,rate+i);
		pool[i]=brr[i]/arr[i];
	}
	sort(pool+1,pool+1+n);
	for(int i=1;i&amp;lt;=n;i++){
		dp[i]=max(dp[i-1],arr[i]*que(rt,1,n,brr[i]/arr[i]));
		double k=dp[i]/(arr[i]*rate[i]+brr[i]);
		mod(rt,1,n,mp(k,k*rate[i]));
	}
	printf(&quot;%.3f&quot;,dp[n]);
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 07 Jun 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/06/07/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/06/07/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>线段树</category>
        
        <category>斜率优化</category>
        
        <category>笔记</category>
        
        
      </item>
    
      <item>
        <title>【题解】寿司晚宴</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;upd 2021.6.18: 修改公式符号，更加形式化，添加 50 分做法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;介绍一种 $O(n \times 3^8)$ 的做法，目前是所有非打表代码中的最优解，&lt;del&gt;其实只是把其他题解中的算法优化了一下。&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;$fac_i$ 表示 i 的质因数集合&lt;/li&gt;
  &lt;li&gt;$P={x\mid x\ \text{is prime},\ x\le n}$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;暴力-1&quot;&gt;暴力 1&lt;/h2&gt;

&lt;p&gt;这题的暴力有很多种，在此只介绍可以优化成正解的暴力。&lt;/p&gt;

&lt;p&gt;两个数互质，等效于他们没有共同的质因子，所以只需把每个数都分解质质因数，如下 dp：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;状态：$dp(s1,s2)$ 表示考虑前 i 个数（i 被滚动掉了），小 G 选的数的包含的质因数集合为 s1，小 W 的质因数集合为 s2 的情况数。&lt;/li&gt;
  &lt;li&gt;转移：
&lt;!--more--&gt;&lt;/li&gt;
&lt;/ul&gt;

\[\begin{aligned}
dp(s1\cup fac_i,s2)\leftarrow dp(s1,s2)+dp(s1\cup fac_i,s2)&amp;amp;\ &amp;amp;(fac_i\cap s2=\varnothing)\cr
dp(s1,s2\cup fac_i)\leftarrow dp(s1,s2)+dp(s1,s2\cup fac_i)&amp;amp;&amp;amp;(fac_i\cap s1=\varnothing)
\end{aligned}\]

&lt;ul&gt;
  &lt;li&gt;答案：&lt;/li&gt;
&lt;/ul&gt;

\[\sum _{s1,s2 \subset P}{dp(s1,s2)\ (s1\cap s2=0))}\]

&lt;p&gt;复杂度 $O(n\times2^{20})$，能得 30 分。&lt;/p&gt;

&lt;h2 id=&quot;暴力-2&quot;&gt;暴力 2&lt;/h2&gt;

&lt;p&gt;（该部分分对正解启发不大，一笔带过）&lt;/p&gt;

&lt;p&gt;$dp(s)$ 表示在 前 i 个数中，选的数质因数集合恰好为 s 的情况数。然后再算出 dp 的子集和，即 $f(s)=\sum_{i \subset s} dp(i)$ ，答案便是 $\sum _{i\subset P}dp(i)f(P \setminus i)$。&lt;/p&gt;

&lt;p&gt;仅仅这样还是不够的，因为小于一百的质数有 25 个，但是发现大于 50  的每个质因数只可能出现一次，所以我们可以只考虑剩下的小于等于 50 的 15 个质数，最后将答案乘以 $3^{\pi(n)-\pi(50)}$ 即可，可得 50 分。&lt;/p&gt;

&lt;h2 id=&quot;正解&quot;&gt;正解&lt;/h2&gt;

&lt;p&gt;$n \le 500$，则小于 n 的质数大概有一百个了，仿佛就无法状压了。但经过仔细观察（看题解），发现每个数只可能有一个大于 $\sqrt{500}=19$ 的质因数，也就是说，每个数除了这个最大质因数之外，剩下的质因数都小于19。&lt;/p&gt;

&lt;p&gt;小于 19 的质因数只有 8 个，不难状压，所以我们只要考虑如何排除那些大质因数的干扰。&lt;/p&gt;

&lt;p&gt;考虑将这些数按其&lt;strong&gt;大质因数&lt;/strong&gt;排序，则大质因数相同的一个连续段中的每个数要么&lt;strong&gt;只被小 G 选或不被选&lt;/strong&gt;，要么&lt;strong&gt;只被小 W 选或不被选&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;考虑如下 dp：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$dp(s1,s2)$ 含义与**暴力 1 **中的差不多，只不过这里的 s1，s2 只状压了前 8 个质数的状态。&lt;/li&gt;
  &lt;li&gt;每次进入一个新的连续段，把 dp 中的值复制到 t1，t2 中。
    &lt;ul&gt;
      &lt;li&gt;用 $dp(s1,s2)$ 表示这个连续段中的数&lt;strong&gt;只被小 G 选或不被选&lt;/strong&gt;的情况数&lt;/li&gt;
      &lt;li&gt;用 $dp(s1,s2)$ 表示这个连续段中的数&lt;strong&gt;只被小 W 选或不被选&lt;/strong&gt;的情况数&lt;/li&gt;
      &lt;li&gt;转移：&lt;/li&gt;
    &lt;/ul&gt;

\[\begin{aligned}
     dp(s1\cup fac_i,s2)\gets dp(s1\cup fac_i,s2)+dp(s1,s2)&amp;amp;\ &amp;amp;(fac_i\cap s2=\varnothing)\cr
     dp(s1,s2\cup fac_i)\gets dp(s1,s2\cup fac_i)+dp(s1,s2)&amp;amp;&amp;amp;(fac_i\cap s1=\varnothing)\cr
     \end{aligned}\]
  &lt;/li&gt;
  &lt;li&gt;这个连续段结束之后，再用 t1，t2 中的值更新 dp 值：&lt;/li&gt;
&lt;/ul&gt;

\[dp(s1,s2)\gets dp(s1,s2)+dp(s1,s2)-dp(s1,s2)\]

&lt;p&gt;为什么要减去 $dp(s1,s2)$ 呢？因为这一段中所有数都不选的情况被算了两次（t1，t2 各一次）。&lt;/p&gt;

&lt;h2 id=&quot;小优化&quot;&gt;小优化&lt;/h2&gt;

&lt;p&gt;截止目前，算法复杂度还是 $O(n \times 4^8)$ 的，但是不难发现对于一个合法状态，是要求 s1，s2 交为空的。因此真正有用的状态数只有 $3^8$ 量级。
所以我们可以如下枚举 s1 和 s2：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int ALL=1&amp;lt;&amp;lt;8;
for(int s1=ALL-1;~s1;s1--){//因为是滚动数组，所以集合必须从大到小枚举
	int tmp=(ALL-1)^s1;//s2 必定是 tmp 的子集
	for(int s2=tmp;s2;s2=(s2-1)&amp;amp;tmp)
		//blabla...
	//单独处理 s2=0 的情况
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

#define fi first
#define se second
typedef pair&amp;lt;int,int&amp;gt; pi;

const int MXPRI=8;
const int ALL=1&amp;lt;&amp;lt;MXPRI;
const int MXN=505;
const int pri[]={2,3,5,7,11,13,17,19};

int n,p,dp[ALL][ALL],t1[ALL][ALL],t2[ALL][ALL];
pi arr[MXN];
inline int mod(int x){return x&amp;lt;p?x:x-p;}

int main(){
	scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;p);
	for(int i=2,j;i&amp;lt;=n;i++)
		for(arr[i].fi=i,j=0;j&amp;lt;MXPRI;j++)
			while(arr[i].fi%pri[j]==0)
				arr[i].fi/=pri[j],arr[i].se|=1&amp;lt;&amp;lt;j;
	sort(arr+2,arr+n+1);
	t1[0][0]=1;
	for(int i=2;i&amp;lt;=n;i++){
		if(arr[i].fi==1 || arr[i].fi!=arr[i-1].fi)
			for(int s1=ALL-1;~s1;s1--){
				int tmp=(ALL-1)^s1;
				for(int s2=tmp;s2;s2=(s2-1)&amp;amp;tmp)
					t1[s1][s2]=t2[s1][s2]=dp[s1][s2]=mod(p-dp[s1][s2]+mod(t1[s1][s2]+t2[s1][s2]));
				t1[s1][0]=t2[s1][0]=dp[s1][0]=mod(p-dp[s1][0]+mod(t1[s1][0]+t2[s1][0]));
			}

		for(int s1=ALL-1,fac=arr[i].se;~s1;s1--){
			int tmp=(ALL-1)^s1;
			for(int s2=tmp;s2;s2=(s2-1)&amp;amp;tmp){
				if(!(fac&amp;amp;s2))t1[s1|fac][s2]=mod(t1[s1|fac][s2]+t1[s1][s2]);
				if(!(fac&amp;amp;s1))t2[s1][s2|fac]=mod(t2[s1][s2|fac]+t2[s1][s2]);
			}
			t1[s1|fac][0]=mod(t1[s1|fac][0]+t1[s1][0]);
			if(!(fac&amp;amp;s1))t2[s1][fac]=mod(t2[s1][fac]+t2[s1][0]);
		}
	}
	int ans=0;
	for(int s1=ALL-1;~s1;s1--){
		int tmp=(ALL-1)^s1;
		for(int s2=tmp;s2;s2=(s2-1)&amp;amp;tmp)
			ans=mod(ans+mod(p-dp[s1][s2]+mod(t1[s1][s2]+t2[s1][s2])));
		ans=mod(ans+mod(p-dp[s1][0]+mod(t1[s1][0]+t2[s1][0])));
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 27 May 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/05/27/%E9%A2%98%E8%A7%A3-%E5%AF%BF%E5%8F%B8%E6%99%9A%E5%AE%B4/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/05/27/%E9%A2%98%E8%A7%A3-%E5%AF%BF%E5%8F%B8%E6%99%9A%E5%AE%B4/</guid>
        
        <category>算法</category>
        
        <category>dp</category>
        
        
      </item>
    
      <item>
        <title>PKUSC游记</title>
        <description>&lt;h2 id=&quot;day-0&quot;&gt;Day 0&lt;/h2&gt;

&lt;p&gt;坐火车到余姚，晚上到余姚宾馆，颓了一会，复习了下教练说往年都考了的ntt和线段树合并，又打了一遍网络流和sa(然而都没用上)，就睡觉了。&lt;/p&gt;

&lt;h2 id=&quot;day-1&quot;&gt;Day 1&lt;/h2&gt;

&lt;p&gt;到考场试机发现是windows系统，好在提供gvim安装包，不过由于我平时都用的是neovim，对gvim的配置不太熟，只好又现查了查，改了下之前背的vimrc。&lt;/p&gt;

&lt;p&gt;第一题，发现每个矩阵只和它前一个矩阵每行每列的和有关，于是就推了下这个东西的递推方法，矩阵快速幂搞定&lt;del&gt;因为交错题又wa又re的调了一个小时&lt;/del&gt;。&lt;/p&gt;

&lt;p&gt;第二题，先写了个暴力，发现整体修改的部分分相当是把询问的l，r移一下，于是写了个st表，把询问离线之后从后往前，在单调栈上二分，得了46分。&lt;/p&gt;

&lt;p&gt;第三题，又是&lt;del&gt;斗地主&lt;/del&gt;德州扑克，写了会放弃了。&lt;/p&gt;

&lt;p&gt;100+46+0=146，同学差不多也是 这个分（有个同学爆切t3,得了38，但t2写的7分做法，总分加起来少了一分&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/62230.png&quot; alt=&quot;/xyx&quot; /&gt;)&lt;/p&gt;

&lt;h2 id=&quot;day-2&quot;&gt;Day 2&lt;/h2&gt;

&lt;p&gt;第一题，大力推式子，写了一个小时。&lt;/p&gt;

&lt;p&gt;第二题，先写了个复杂度和值域有关的暴力dp。后来仔细想想觉得这个过程是可以贪心的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于每道菜价格mod c的余数部分金额，是可以随便用代金券的。&lt;/li&gt;
  &lt;li&gt;此最后一道菜肯定会尽量用代金券，因为再不用之后就没机会了，而如果最后一道菜完全用代金券支付，代金券还有剩余，那么第二道菜就会尽量用代金券，以此类推（差不多是这个意思，具体有点细节）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;得出一个结论：一个最优解必分为三段，前面一段对于余数部分尽量用代金券，中间是单独的一道菜，后面部分完全用代金券支付。&lt;/p&gt;

&lt;p&gt;于是可以预处理出在第一个策略下，每个前缀中能净赚到的代金券数，以及前缀中花的钱，每次枚举前面一段的长度，计算出中间那道菜最少花多少钱（这个有二分性，可以直接除），加上前缀中花的钱取min，这样算复杂度$O(n^2)$。&lt;/p&gt;

&lt;p&gt;对c=1的情况，可以用树状数组维护前缀中赚的代金券和花的钱（就是价格的前缀和），发现后面的枚举其实也可以用二分替代，可以$O(Q \log n)$解决。&lt;/p&gt;

&lt;p&gt;听说这样离正解只差用线段树维护那个前缀中赚的代金券和花的钱了，但是我就是死活想不出怎么维护c不等于1的情况，于是51分滚粗。&lt;/p&gt;

&lt;p&gt;第三题，没有subtask，输出1得5分，考完听说输出0还可以再得5分。&lt;/p&gt;

&lt;p&gt;考场上没啥思路，尝试积了个分，结果算出负的概率来。还尝试随机撒点，估算出概率的double值，然后找一个比较接近的分数输出，但是都以失败告终。&lt;/p&gt;

&lt;p&gt;100+51+5=156，一些同学没写第二题的贪心分，自我感觉还可以。&lt;/p&gt;

&lt;h2 id=&quot;day-3&quot;&gt;Day 3&lt;/h2&gt;

&lt;p&gt;面试问了一些奇怪的问题，后面就颁奖了。&lt;/p&gt;

&lt;p&gt;总分302，初三的不少大佬没来，分数线不太高，于是就1=了&lt;img src=&quot;https://cdn.luogu.com.cn/upload/pic/62225.png&quot; alt=&quot;/cy&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 17 May 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/05/17/PKUSC%E6%B8%B8%E8%AE%B0/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/05/17/PKUSC%E6%B8%B8%E8%AE%B0/</guid>
        
        <category>算法</category>
        
        <category>游记</category>
        
        <category>PKUSC</category>
        
        
      </item>
    
      <item>
        <title>一种很优雅的高斯消元写法</title>
        <description>&lt;p&gt;rt，自己胡出来的算法。用类似线性基的写法写，代码简短，常数小，并且对无解和无穷解的判断都很简单。&lt;/p&gt;

&lt;p&gt;以下为毒瘤题 &lt;a href=&quot;https://www.luogu.com.cn/problem/P2455&quot;&gt;P2455 线性方程组&lt;/a&gt; 代码（之前用正常写法怎么都过不了，面向数据才过的。。）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int MXN=105;
const double eps=1e-8;
int n;
bool used[MXN];
double arr[MXN][MXN],tmp[MXN];
inline bool is0(double x){return fabs(x)&amp;lt;=eps;}
inline void eli(double *a,double *b,int ind){
    if(is0(a[ind]))return;
    double rate=a[ind]/b[ind];
    for(int i=ind;i&amp;lt;=n+1;i++)a[i]-=rate*b[i];
}
inline int insert(double *eq){
	for(int i=1;i&amp;lt;=n;i++)
		if(!is0(eq[i])){
			if(used[i])eli(eq,arr[i],i);
			else{
				for(int j=i+1;j&amp;lt;=n;j++)if(used[j])eli(eq,arr[j],j);
				for(int j=1;j&amp;lt;i;j++)eli(arr[j],eq,i);
				for(int j=i;j&amp;lt;=n+1;j++)arr[i][j]=eq[j];
				return used[i]=1;
			}
		}
	return is0(eq[n+1])?0:-1;
}

int main(){
	scanf(&quot;%d&quot;,&amp;amp;n);
	bool infsol=0;
	for(int i=1;i&amp;lt;=n;i++){
		for(int j=1;j&amp;lt;=n+1;j++)scanf(&quot;%lf&quot;,tmp+j);
		int tres=insert(tmp);
		if(tres==-1)return printf(&quot;-1&quot;),0;
		infsol|=!tres;
	}
	if(infsol)printf(&quot;0&quot;);
	else
		for(int i=1;i&amp;lt;=n;i++)
			printf(&quot;x%d=%.2f\n&quot;,i,arr[i][n+1]/arr[i][i]+eps);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 09 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/04/09/%E4%B8%80%E7%A7%8D%E5%BE%88%E4%BC%98%E9%9B%85%E7%9A%84%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E5%86%99%E6%B3%95/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/04/09/%E4%B8%80%E7%A7%8D%E5%BE%88%E4%BC%98%E9%9B%85%E7%9A%84%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E5%86%99%E6%B3%95/</guid>
        
        <category>高斯消元</category>
        
        
      </item>
    
      <item>
        <title>USACO 2021 US Open 铂金组 T1 题解</title>
        <description>&lt;h2 id=&quot;united-cows-of-farmer-john&quot;&gt;United Cows of Farmer John&lt;/h2&gt;
&lt;h3 id=&quot;题意&quot;&gt;题意：&lt;/h3&gt;
&lt;p&gt;给定一个长度为 n 的数列 $a_i$，求符合下列条件的三元组 ${i,j,k}$ 个数：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$1\le i &amp;lt; j &amp;lt; k \le n$&lt;/li&gt;
  &lt;li&gt;$a_i,a_j,a_k$ 的值在 $a_{[i,k]}$ 各只出现一次（即他们自己）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;思路&quot;&gt;思路：&lt;/h3&gt;

&lt;p&gt;为了方便描述，我们称 $a_i$ 为 i 点的颜色，记 $pre_i$ 表示 $a_i$ 的前驱（即 i 之前与 $a_i$ 相同的最后一个数），记集合 $last$ 表示右端点扫描到 r 时，每个颜色最后一次出现的位置。&lt;/p&gt;

&lt;h4 id=&quot;朴素想法&quot;&gt;朴素想法&lt;/h4&gt;

&lt;p&gt;考虑固定右端点 r，然后枚举左端点 l 的位置，求此时 m 有多少种选择。发现答案即为 $a_{[l+1,r-1]}$ 中仅出现过一次的颜色数。&lt;/p&gt;

&lt;p&gt;为了方便计算，我们可以使用代表元法。即随着 r 的向右推进，维护一个序列 $appear_i$：&lt;/p&gt;

\[appear_i=\left\{
\begin{aligned}
1\qquad&amp;amp;(a_{[i+1,r]}中没有与a_i相同的颜色)\cr
-1\qquad&amp;amp;(a_{[i+1,r]}中恰有一个与a_i相同的颜色)\cr
0\qquad&amp;amp;(a_{[i+1,r]}中有多于一个与a_i相同的颜色)
\end{aligned}
\right.\]

&lt;p&gt;具体的维护方式就是每当 r 右移到新的一位，就进行以下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;appear[i]++;
appear[pre[i]]-=2;
appear[pre[pre[i]]]++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后每次暴力枚举 l，并将后缀和加起来，我们就得到了一个 $O(n^2)$ 的做法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：
当然，在 r 固定的情况下，l 也是有限制的，即：$l &amp;gt; pre[r]$ 并且 $l \in last$。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;线段树优化&quot;&gt;线段树优化&lt;/h4&gt;

&lt;p&gt;虽然在枚举 l 的时候有 $l \in last$ 的限制，但是这个二重后缀求和仍有希望用数据结构维护。&lt;/p&gt;

&lt;p&gt;记数组 $sumappear_i$ 表示以下的内容：&lt;/p&gt;

\[sumappear_i=\left\{
\begin{aligned}
\sum_{j=i+1}^{r-1}appear_j \qquad&amp;amp;(i \in last)\cr
0\qquad&amp;amp;(i \notin last)
\end{aligned}
\right.\]

&lt;p&gt;则对 $appear_i$ 的修改可以转化为对 $sumappear$ 前缀第 $j(j\in last \cap [1,i])$ 位的修改。而枚举 l 的过程也可以转化为对 $sumappear$ 第 $j,j\in[pre_r+1,r-1]$ 的求和。&lt;/p&gt;

&lt;p&gt;考虑用线段树维护这个信息，在每个节点上不仅要存区间的权值和，还要存一个 &lt;code&gt;cnt&lt;/code&gt; 表示区间内有多少项在 $last$ 集合里，每当 r 右移到新的一位，就将 $sumappear_i$ 的 &lt;code&gt;cnt&lt;/code&gt; 设为 1，并将 $sumappear_{pre_i}$ 的 &lt;code&gt;cnt&lt;/code&gt; 设为 0，给区间打 tag 时也按照 &lt;code&gt;sum+=cnt*tag&lt;/code&gt; 加，于是这就是一个 $O(n\log n)$ 的算法。&lt;/p&gt;

&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define rd scanf
#define pt printf
#define setp(x) setprecision(x)
#define mem(x,y) memset(x,y,sizeof(x))
#define umn(x,y) x=min(x,y)
#define umx(x,y) x=max(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef pair&amp;lt;ll,ll&amp;gt; pi;
typedef queue&amp;lt;ll&amp;gt; qi;
typedef vector&amp;lt;ll&amp;gt; vi;
typedef vector&amp;lt;pi&amp;gt; vpi;

const ll INF=1e18;
const ll P=1e9+7;
const ll MXN=2e5+5;

inline ll mod(const ll &amp;amp;x){return x&amp;gt;=P?x-P:x;}
inline ll mul(ll x,ll y){if(x&amp;lt;y)swap(x,y);ll res=0;while(y){if(y&amp;amp;1)res=mod(res+x);x=mod(x&amp;lt;&amp;lt;1);y&amp;gt;&amp;gt;=1;}return res;}
inline ll qpow(ll x,ll y){ll res=1;while(y){if(y&amp;amp;1)res=res*x%P;x=x*x%P;y&amp;gt;&amp;gt;=1;}return res;}
ll gcd(const ll &amp;amp;x,const ll &amp;amp;y){return !y?x:gcd(y,x%y);}
inline void pbin(const ll &amp;amp;x,ll y){for(;~y;y--)cerr&amp;lt;&amp;lt;char('0'+((x&amp;gt;&amp;gt;y)&amp;amp;1));cerr&amp;lt;&amp;lt;endl;}

ll n,arr[MXN],res;
ll last[MXN],pre[MXN];

#define ls (p&amp;lt;&amp;lt;1)
#define rs (p&amp;lt;&amp;lt;1|1)
const ll NR=MXN&amp;lt;&amp;lt;2;
struct node{
	ll va,sz,tag;
	inline node(ll va=0,ll sz=0,ll tag=0):va(va),sz(sz),tag(tag){}
	inline void addt(ll k){
		tag+=k;
		va+=sz*k;
	}
	inline node operator + (const node &amp;amp;y)const{return node(va+y.va,sz+y.sz);}
}t[NR];
inline void pushu(ll p){t[p]=t[ls]+t[rs];}
inline void pushd(ll p){
	t[ls].addt(t[p].tag);
	t[rs].addt(t[p].tag);
	t[p].tag=0;
}
void build(ll p,ll l,ll r){
	if(l==r){
		t[p]=node(-2,1);
		return;
	}
	ll mid=(l+r)&amp;gt;&amp;gt;1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushu(p);
}
void del(ll p,ll l,ll r,ll dx){
	if(l==r){
		t[p].sz=t[p].va=0;
		return;
	}
	ll mid=(l+r)&amp;gt;&amp;gt;1;
	pushd(p);
	if(dx&amp;lt;=mid)del(ls,l,mid,dx);
	else del(rs,mid+1,r,dx);
	pushu(p);
}
void mod(ll p,ll l,ll r,ll ml,ll mr,ll mx){
	if(ml&amp;lt;=l &amp;amp;&amp;amp; r&amp;lt;=mr){
		t[p].addt(mx);
		return;
	}
	ll mid=(l+r)&amp;gt;&amp;gt;1;
	pushd(p);
	if(ml&amp;lt;=mid)mod(ls,l,mid,ml,mr,mx);
	if(mr&amp;gt;mid)mod(rs,mid+1,r,ml,mr,mx);
	pushu(p);
}
node que(ll p,ll l,ll r,ll ql,ll qr){
	if(ql&amp;lt;=l &amp;amp;&amp;amp; r&amp;lt;=qr)return t[p];
	ll mid=(l+r)&amp;gt;&amp;gt;1;node res;
	pushd(p);
	if(ql&amp;lt;=mid)res=res+que(ls,l,mid,ql,qr);
	if(qr&amp;gt;mid)res=res+que(rs,mid+1,r,ql,qr);
	return res;
}


inline void solve(){
	scanf(&quot;%lld&quot;,&amp;amp;n);
	build(1,1,n);
	for(int i=1;i&amp;lt;=n;i++){
		scanf(&quot;%lld&quot;,arr+i);
		pre[i]=last[arr[i]];
		last[arr[i]]=i;
		
		if(pre[i])del(1,1,n,pre[i]);
		mod(1,1,n,1,i,1);
		if(pre[i])mod(1,1,n,1,pre[i],-2);
		if(pre[pre[i]])mod(1,1,n,1,pre[pre[i]],1);
		if(pre[i]+2&amp;lt;=i)res+=que(1,1,n,pre[i]+1,i-1).va;
	}
	printf(&quot;%lld&quot;,res);
    
}
int main(){
	//freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;.out&quot;,&quot;w&quot;,stdout);
	//ios_base::sync_with_stdio(0);cin.tie(0);
	cout&amp;lt;&amp;lt;setiosflags(ios::fixed);
	srand(time(NULL));

	ll tq=1;
	//cin&amp;gt;&amp;gt;tq;
	while(tq--)solve();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/04/06/USACO-2021-US-Open-%E9%93%82%E9%87%91%E7%BB%84-T1-%E9%A2%98%E8%A7%A3/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/04/06/USACO-2021-US-Open-%E9%93%82%E9%87%91%E7%BB%84-T1-%E9%A2%98%E8%A7%A3/</guid>
        
        <category>算法</category>
        
        <category>题解</category>
        
        <category>USACO</category>
        
        <category>线段树</category>
        
        
      </item>
    
      <item>
        <title>USACO 2021 US Open 金组题解</title>
        <description>&lt;h2 id=&quot;t1-united-cows-of-farmer-john&quot;&gt;T1 United Cows of Farmer John&lt;/h2&gt;

&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;

&lt;p&gt;这题比较水，记 $pre_i$ 为 i 号奶牛的前驱（即 i 前面最靠后的与 i 号奶牛颜色相同的奶牛）。&lt;/p&gt;

&lt;p&gt;令这两个奶牛领导中，在序列中靠后的那个为 i，考虑靠前的奶牛领导有几种可能，不难发现其个数为 $[pre_i+1,i-1]$ 这段区间内奶牛的种类数。于是直接上树状数组，用代表元法（将每种种类的最后出现位置加一）即可求出答案。复杂度 $O(n\log n)$&lt;/p&gt;

&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define rd scanf
#define pt printf
#define setp(x) setprecision(x)
#define mem(x,y) memset(x,y,sizeof(x))
#define sz(x) (int)x.size()
#define umn(x,y) x=min(x,y)
#define umx(x,y) x=max(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef pair&amp;lt;ll,ll&amp;gt; pi;
typedef queue&amp;lt;ll&amp;gt; qi;
typedef vector&amp;lt;ll&amp;gt; vi;
typedef vector&amp;lt;pi&amp;gt; vpi;

const ll INF=1e18;
const ll P=1e9+7;
const ll MXN=2e5+5;

inline ll mod(ll x){return x&amp;gt;=P?x-P:x;}
inline ll mul(ll x,ll y){if(x&amp;lt;y)swap(x,y);ll res=0;while(y){if(y&amp;amp;1)res=mod(res+x);x=mod(x&amp;lt;&amp;lt;1);y&amp;gt;&amp;gt;=1;}return res;}
inline ll qpow(ll x,ll y){ll res=1;while(y){if(y&amp;amp;1)res=res*x%P;x=x*x%P;y&amp;gt;&amp;gt;=1;}return res;}
ll gcd(ll x,ll y){return !y?x:gcd(y,x%y);}
inline void pbin(ll x,ll y){for(;~y;y--)cerr&amp;lt;&amp;lt;char('0'+((x&amp;gt;&amp;gt;y)&amp;amp;1));cerr&amp;lt;&amp;lt;endl;}



ll n,m,tmp,res;
ll c[MXN],last[MXN];
inline void mod(ll x,ll y){for(;x&amp;lt;=n;x+=x&amp;amp;(-x))c[x]+=y;}
inline ll sum(ll x){ll res=0;for(;x;x-=x&amp;amp;(-x))res+=c[x];return res;}
inline void solve(){
	scanf(&quot;%lld&quot;,&amp;amp;n);
	for(int i=1;i&amp;lt;=n;i++){
		scanf(&quot;%lld&quot;,&amp;amp;tmp);
		res+=sum(i)-sum(last[tmp]);
		if(last[tmp])mod(last[tmp],-1);
		mod(last[tmp]=i,1);
	}
	printf(&quot;%lld&quot;,res);
    
}
int main(){
	//freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;.out&quot;,&quot;w&quot;,stdout);
	//ios_base::sync_with_stdio(0);cin.tie(0);
	cout&amp;lt;&amp;lt;setiosflags(ios::fixed);
	srand(time(NULL));

	ll tq=1;
	//cin&amp;gt;&amp;gt;tq;
	while(tq--)solve();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;t2-portals&quot;&gt;T2 Portals&lt;/h2&gt;

&lt;h3 id=&quot;题意&quot;&gt;题意&lt;/h3&gt;

&lt;p&gt;这题题意比较难懂，我看了半天才看明白。简化的大意就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有 2n 个点，以及 n 个四元组。&lt;/li&gt;
  &lt;li&gt;四元组 $p_1,p_2,p_3,p_4$ 代表 $p_1$ 向 $p_2$ 连一条无向边，$p_3$ 向 $p_4$ 连一条无向边&lt;/li&gt;
  &lt;li&gt;你可以花 $c_i$ 的代价将第 i 个四元组重新排列&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;保证初始状态下每个点的度数都为 2&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;求使得整个图联通的最小代价&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;思路-1&quot;&gt;思路&lt;/h3&gt;

&lt;p&gt;看到这题立刻感觉这可能是一道巧妙的最小生成树题（前一阵省选集训就有一道最小生成树题我没做出来，故印象深刻），手玩了几组发现确实是这样的。&lt;/p&gt;

&lt;p&gt;初始情况下，图被分成若干个联通块，并且对于任意四元组，有结论 $p_1$ 与 $p_2$，$p_3$ 与 $p_4$ 在同一个联通块中（都连边了所以显然）。使整个图联通，就是要把这些联通块都合并起来。&lt;/p&gt;

&lt;p&gt;根据每个节点的度数都为 2 的关键性质，不难证明每个联通块都&lt;strong&gt;必定是一个环&lt;/strong&gt;。所以对于一个四元组，如果 $p_1$ 与 $p_3$ 不在同一块中，那么我就可以通过重排这个四元组，把这两个点所在的块合并，并且产生的新的联通块仍然是一个环！如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.imgdb.cn/item/60687ed38322e6675c6d5c59.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以这题的做法就显而易见了，我们先将每个联通块缩成一个点，然后从每个四元组的前两个点所在块向后两个点所在块连边，边权为 $c_i$，然后跑 kruskal 即可。&lt;/p&gt;

&lt;h3 id=&quot;代码-1&quot;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define rd scanf
#define pt printf
#define setp(x) setprecision(x)
#define mem(x,y) memset(x,y,sizeof(x))
#define sz(x) (int)x.size()
#define umn(x,y) x=min(x,y)
#define umx(x,y) x=max(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef pair&amp;lt;ll,ll&amp;gt; pi;
typedef queue&amp;lt;ll&amp;gt; qi;
typedef vector&amp;lt;ll&amp;gt; vi;
typedef vector&amp;lt;pi&amp;gt; vpi;

const ll INF=1e18;
const ll P=1e9+7;
const ll MXN=2e5+5;

inline ll mod(ll x){return x&amp;gt;=P?x-P:x;}
inline ll mul(ll x,ll y){if(x&amp;lt;y)swap(x,y);ll res=0;while(y){if(y&amp;amp;1)res=mod(res+x);x=mod(x&amp;lt;&amp;lt;1);y&amp;gt;&amp;gt;=1;}return res;}
inline ll qpow(ll x,ll y){ll res=1;while(y){if(y&amp;amp;1)res=res*x%P;x=x*x%P;y&amp;gt;&amp;gt;=1;}return res;}
ll gcd(ll x,ll y){return !y?x:gcd(y,x%y);}
inline void pbin(ll x,ll y){for(;~y;y--)cerr&amp;lt;&amp;lt;char('0'+((x&amp;gt;&amp;gt;y)&amp;amp;1));cerr&amp;lt;&amp;lt;endl;}


struct edge{
	ll ts,tt,tw;
	edge(ll ts=0,ll tt=0,ll tw=0):ts(ts),tt(tt),tw(tw){}
	bool operator &amp;lt; (const edge &amp;amp;b)const{return tw&amp;lt;b.tw;}
}ne[MXN];

ll n,res,colc,color[MXN];
vector&amp;lt;ll&amp;gt; e[MXN];
void dfs(ll p){
	color[p]=colc;
	for(size_t i=0;i&amp;lt;e[p].size();i++){
		ll nx=e[p][i];
		if(color[nx])continue;
		dfs(nx);
	}
}

ll fa[MXN];
ll find(ll x){return x==fa[x]?x:fa[x]=find(fa[x]);}
inline void solve(){
	scanf(&quot;%lld&quot;,&amp;amp;n);
	for(int i=1;i&amp;lt;=n;i++){
		ll x,y,z,w,va;
		scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;amp;va,&amp;amp;x,&amp;amp;y,&amp;amp;z,&amp;amp;w);
		ne[i]=edge(x,z,va);
		e[x].pb(y),e[y].pb(x);
		e[z].pb(w),e[w].pb(z);
	}
	for(int i=1;i&amp;lt;=(n&amp;lt;&amp;lt;1);i++)
		if(!color[i]){
			++colc;
			fa[colc]=colc;
			dfs(i);
		}
	for(int i=1;i&amp;lt;=n;i++)
		ne[i].ts=color[ne[i].ts],ne[i].tt=color[ne[i].tt];
	sort(ne+1,ne+1+n);
	for(int i=1;i&amp;lt;=n;i++)
		if(find(ne[i].ts)!=find(ne[i].tt)){
			fa[fa[ne[i].ts]]=fa[ne[i].tt];
			res+=ne[i].tw;
		}
	printf(&quot;%lld&quot;,res);
}
int main(){
	//freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;.out&quot;,&quot;w&quot;,stdout);
	ios_base::sync_with_stdio(0);cin.tie(0);
	cout&amp;lt;&amp;lt;setiosflags(ios::fixed);
	srand(time(NULL));

	ll tq=1;
	//cin&amp;gt;&amp;gt;tq;
	while(tq--)solve();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;t3-permutation&quot;&gt;T3 Permutation&lt;/h2&gt;

&lt;h3 id=&quot;思路-2&quot;&gt;思路&lt;/h3&gt;

&lt;p&gt;第一次接触计算几何类的题，没想到还写对了哈哈！&lt;/p&gt;

&lt;h4 id=&quot;key-observation&quot;&gt;Key Observation&lt;/h4&gt;

&lt;p&gt;对于一个合法的加点顺序，在任意时刻，这个图形都是一个内部被划分为若干个小三角形的大三角形。这个结论可以归纳证明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在加入了前三个点后，图形为一个三角形，结论成立。&lt;/li&gt;
  &lt;li&gt;设加入了前 k 个点时，结论仍然成立，且最外围的三角形由 A，B，C 构成，讨论加入第 k+1 个点 P 之后的情况：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;如果新加入的点在三角形 ABC 外，则这个点能且只能向 A，B，C 连边，并且这个点只能在下图中的蓝色阴影中（否则将只能连两条边）。以 P 在 A 上方阴影处为例，结论显然成立，而 B，C 都是对称的，所以也成立。
&lt;img src=&quot;https://img.imgdb.cn/item/606884e38322e6675c745166.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果新加入的点在三角形 ABC 内，并在某个小三角形 abc 内，则能且只能由 P 向 a，b，c 连边，可见结论依然成立。
&lt;img src=&quot;https://img.imgdb.cn/item/606886bc8322e6675c7652ee.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;所以，对于 $\forall k \in [3,n]$，结论成立。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;dp-状态与转移&quot;&gt;DP 状态与转移&lt;/h4&gt;

&lt;p&gt;到这里，dp 状态也就呼之欲出了：$dp[i][j][k][l]$ 表示当前图形的最外围的三角形由 i，j，k 构成，并且在这个三角形的内部（不包括顶点）我们已经选了 l 个点的总方案数。&lt;/p&gt;

&lt;p&gt;此外，我们还需要预处理一个辅助的数组 $cnt[i][j][k]$ 代表三角形 ijk 之内有多少个点（不包括三个顶点）。&lt;/p&gt;

&lt;p&gt;转移的顺序是什么？将三元组 $(i,j,k)$ 按照 $cnt[i][j][k]$ 排序即可，因为在转移的过程中，最外围的三角只会扩张，不会缩小，所以这样就没有后效性了。&lt;/p&gt;

&lt;p&gt;如何转移呢？考虑我为人人型 dp，在当前的状态下，我取的下一个点 P 可能是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;三角形 ijk 内部的点：$dp[i][j][k][l+1]+=dp[i][j][k][l]\times(cnt[i][j][k]-l)$&lt;/li&gt;
  &lt;li&gt;三角形 ijk 外部的点：枚举新加的点，新的状态的前三维需要重新计算，代表新的大三角的顶点，而第四维还是 l+1。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是我们就实现了一个 $O(n^5)$ 的 dp，是可以通过 $n=40$ 的这题的。但是在上述算法预处理，以及重新计算dp的前三维时，需要判断某个点是否在另外三个点组成的三角形内，我们下面介绍如何实现。&lt;/p&gt;

&lt;h3 id=&quot;判断是否在三角形内&quot;&gt;判断是否在三角形内&lt;/h3&gt;

&lt;p&gt;假设我们要判定 P 是否在三角形 ABC 内，即判定 P 是否在 AB，BC，CA 同侧。即：$\vec{AP}\times\vec{AB}$，$\vec{BP}\times\vec{BC}$，$\vec{CP}\times\vec{CA}$ 的奇偶性相同，手写个向量类型就能够实现了。&lt;/p&gt;

&lt;h3 id=&quot;代码-2&quot;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define rd scanf
#define pt printf
#define setp(x) setprecision(x)
#define mem(x,y) memset(x,y,sizeof(x))
#define sz(x) (int)x.size()
#define umn(x,y) x=min(x,y)
#define umx(x,y) x=max(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef pair&amp;lt;ll,ll&amp;gt; pi;
typedef queue&amp;lt;ll&amp;gt; qi;
typedef vector&amp;lt;ll&amp;gt; vi;
typedef vector&amp;lt;pi&amp;gt; vpi;

const ll INF=1e18;
const ll P=1e9+7;
const ll MXN=45;

inline ll mod(const ll &amp;amp;x){return x&amp;gt;=P?x-P:x;}
inline ll mul(ll x,ll y){if(x&amp;lt;y)swap(x,y);ll res=0;while(y){if(y&amp;amp;1)res=mod(res+x);x=mod(x&amp;lt;&amp;lt;1);y&amp;gt;&amp;gt;=1;}return res;}
inline ll qpow(ll x,ll y){ll res=1;while(y){if(y&amp;amp;1)res=res*x%P;x=x*x%P;y&amp;gt;&amp;gt;=1;}return res;}
ll gcd(ll x,ll y){return !y?x:gcd(y,x%y);}
inline void pbin(ll x,ll y){for(;~y;y--)cerr&amp;lt;&amp;lt;char('0'+((x&amp;gt;&amp;gt;y)&amp;amp;1));cerr&amp;lt;&amp;lt;endl;}



ll n,top;
ll cnt[MXN][MXN][MXN],dp[MXN][MXN][MXN][MXN];
struct vec{
	ll x,y;
	vec(ll x=0,ll y=0):x(x),y(y){}
	vec operator + (const vec &amp;amp;b)const{return vec(x+b.x,y+b.y);}
	vec operator - (const vec &amp;amp;b)const{return vec(x-b.x,y-b.y);}
	ll operator * (const vec &amp;amp;b)const{return x*b.y-b.x*y;}
}arr[MXN];
inline bool intri(const vec &amp;amp;x,const vec &amp;amp;a,const vec &amp;amp;b,const vec &amp;amp;c){
	ll res_ab=(b-a)*(x-a);
	ll res_bc=(c-b)*(x-b);
	ll res_ca=(a-c)*(x-c);
	return (res_ab&amp;gt;0 &amp;amp;&amp;amp; res_bc&amp;gt;0 &amp;amp;&amp;amp; res_ca&amp;gt;0) || (res_ab&amp;lt;0 &amp;amp;&amp;amp; res_bc&amp;lt;0 &amp;amp;&amp;amp; res_ca&amp;lt;0);
}
inline bool expand(const ll &amp;amp;x,ll &amp;amp;a,ll &amp;amp;b,ll &amp;amp;c){
	if(intri(arr[a],arr[x],arr[b],arr[c]))a=x;
	else if(intri(arr[b],arr[x],arr[c],arr[a]))b=x;
	else if(intri(arr[c],arr[x],arr[a],arr[b]))c=x;
	else return 0;

	if(a&amp;gt;b)swap(a,b);
	if(b&amp;gt;c)swap(b,c);
	if(a&amp;gt;b)swap(a,b);

	return 1;
}
struct status{
	ll i,j,k;
	bool operator &amp;lt; (const status &amp;amp;b)const{return cnt[i][j][k]&amp;lt;cnt[b.i][b.j][b.k];}
}sta[MXN*MXN*MXN];
inline void solve(){
	scanf(&quot;%lld&quot;,&amp;amp;n);
	for(int i=1;i&amp;lt;=n;i++)scanf(&quot;%lld%lld&quot;,&amp;amp;arr[i].x,&amp;amp;arr[i].y);

	ll mx=0;
	for(int i=1;i&amp;lt;=n;i++)
		for(int j=i+1;j&amp;lt;=n;j++)
			for(int k=j+1;k&amp;lt;=n;k++){
				for(int l=1;l&amp;lt;=n;l++)
					cnt[i][j][k]+=intri(arr[l],arr[i],arr[j],arr[k]);
				mx=max(mx,cnt[i][j][k]);
				dp[i][j][k][0]=6;
				sta[++top]=status{i,j,k};
			}
	if(mx&amp;lt;n-3){
		printf(&quot;0&quot;);
		return;
	}
	sort(sta+1,sta+1+top);
	//当前边框为i，j，k，边框内选了l个
	for(int stai=1;stai&amp;lt;=top;stai++){
		ll i=sta[stai].i,j=sta[stai].j,k=sta[stai].k;

		ll tmp=cnt[i][j][k],ni,nj,nk;
		for(int l=0;l&amp;lt;=tmp;l++){
			dp[i][j][k][l+1]=(dp[i][j][k][l+1]+dp[i][j][k][l]*(cnt[i][j][k]-l))%P;
			ni=i,nj=j,nk=k;
			for(int m=1;m&amp;lt;=n;m++)
				if(expand(m,ni,nj,nk)){
					dp[ni][nj][nk][l+1]=mod(dp[ni][nj][nk][l+1]+dp[i][j][k][l]);
					ni=i,nj=j,nk=k;
				}
		}
	}
	printf(&quot;%lld&quot;,dp[sta[top].i][sta[top].j][sta[top].k][n-3]);
}
int main(){
	ios_base::sync_with_stdio(0);cin.tie(0);
	srand(time(NULL));

	ll tq=1;
	while(tq--)solve();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 03 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/04/03/USACO-2021-US-Open-%E9%87%91%E7%BB%84%E9%A2%98%E8%A7%A3/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/04/03/USACO-2021-US-Open-%E9%87%91%E7%BB%84%E9%A2%98%E8%A7%A3/</guid>
        
        <category>算法</category>
        
        <category>题解</category>
        
        <category>USACO</category>
        
        
      </item>
    
      <item>
        <title>【题解】P3747 相逢是问候</title>
        <description>&lt;h2 id=&quot;题意&quot;&gt;题意&lt;/h2&gt;

&lt;p&gt;定义函数 $f(x)=c^x$&lt;/p&gt;

&lt;p&gt;维护给定序列 $a_i$，支持两种操作（p，c 由输入给定）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将数列第 l 到 r 项中的每一项 $a_i$，赋值为 $f(a_i)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询 $\sum_{i=l}^{i\leq r}a_i\ \pmod p$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;

&lt;h3 id=&quot;计算方法&quot;&gt;计算方法&lt;/h3&gt;

&lt;p&gt;首先考虑一项如何计算，由扩展欧拉定理（详见 &lt;a href=&quot;https://oi-wiki.org/math/fermat/#_5&quot;&gt;OI-wiki&lt;/a&gt;）&lt;/p&gt;

\[a^b\equiv \begin{cases} a^{b\bmod\varphi(p)},\,&amp;amp;\gcd(a,\,p)=1\\ a^b,&amp;amp;\gcd(a,\,p)\ne1,\,b&amp;lt;\varphi(p)\\ a^{b\bmod\varphi(p)+\varphi(p)},&amp;amp;\gcd(a,\,p)\ne1,\,b\ge\varphi(p) \end{cases} \pmod p\]

&lt;p&gt;可以转化问题为:&lt;/p&gt;

\[\begin{align}
&amp;amp;f^x(a_i) \pmod p\\
=&amp;amp;\begin{cases} 
f(f^{x-1}(a_i))&amp;amp;(f^{x-1}(a_i)&amp;lt;\varphi(p))\\
f(f^{x-1}(a_i)\bmod \varphi(p)+\varphi(p))&amp;amp;(f^{x-1}(a_i)\ge\varphi(p))
\end{cases}
\end{align}\]

&lt;p&gt;以此类推，就能递归求解答案，不妨设 $\varphi ^t (p)=1$ 当且仅当 $t\ge z$，则递归的边界为：&lt;/p&gt;

\[\begin{cases}
a_i &amp;amp;\pmod {\varphi^{z-x}(p)}&amp;amp;(x&amp;lt;z)\\ 
f^{x-z}(a_i) &amp;amp;\pmod 1&amp;amp;(x\ge z)
\end{cases}\]

&lt;p&gt;又因为 z 的大小&lt;strong&gt;是  $\log p$ 量级的&lt;/strong&gt;，所以递归次数也是 log 量级的，每次计算需要调用一次快速幂（可以优化），所以算法复杂度为两个 log。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于 z 大小的证明：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;p 为偶数时，$\varphi(p)\leq \frac p 2$&lt;/li&gt;
    &lt;li&gt;p为奇数时，$\varphi(p)$ 为偶数&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;计算次数&quot;&gt;计算次数&lt;/h3&gt;

&lt;p&gt;通过刚才的计算方法，我们发现：若 $x\ge z$，则函数在边界处的返回值为 0，接下来整个计算过程都&lt;strong&gt;与 x 无关&lt;/strong&gt;。也即：每个元素 $a_i$ 在操作了 z 次之后，其值就&lt;strong&gt;不再变化&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;所以，我们可以用一个线段树来维护区间和，以及区间内操作次数最少的元素操作了多少次，修改时，如果区间内的最少操作次数小于 z，那么就暴力计算之，并更新线段树。这样就能实现一个 $O(n\log n \log p^2+m\log n)$ 的做法，得到 90 分的好成绩。&lt;/p&gt;

&lt;h3 id=&quot;小优化&quot;&gt;小优化&lt;/h3&gt;

&lt;p&gt;考虑如何优化前文所述的快速幂，因为底数 c 是已知的，而指数小于等于 p，于是我们可预处理出 $c^i\ (i\in[1, \sqrt p] )$ 以及 $c^{i \times  \sqrt p}\ (i\in[1, \sqrt p])$，每次求快速幂直接把 $c^{i\ \bmod \sqrt p}$ 与 $c^{\lfloor\frac i {\sqrt p }\rfloor\times \sqrt p}$ 拼接即可。&lt;/p&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;（还挺快的）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
const ll MXN=5e4+5;
const ll MXD=65;
const ll LG=14;
ll n,m,P,c;
ll arr[MXN];
ll phip[MXD],phic;
ll powc1[MXD][(1&amp;lt;&amp;lt;LG)+5],powc2[MXD][(1&amp;lt;&amp;lt;LG)+5];
inline ll phi(ll x){
	ll res=x;
	for(int i=2;i*i&amp;lt;=x;i++)
		if(x%i==0){
			while(x%i==0)x/=i;
			res-=res/i;
		}
	if(x!=1)res-=res/x;
	return res;
}
//方便处理扩展欧拉定理
inline ll eulermod(ll x,ll mod){return x&amp;lt;=mod?x:(x%mod+mod);}
inline ll qmod(ll x,ll mod){return x&amp;lt;mod?x:x-mod;}
inline ll qpow(ll y,ll modi){return eulermod(powc1[modi][y&amp;amp;((1&amp;lt;&amp;lt;LG)-1)]*powc2[modi][y&amp;gt;&amp;gt;LG],phip[modi]);}
//第 0 层的数，当前剩下的嵌套层数，当前模数的下标
inline ll cal(ll va,ll cflr,ll cphi){
	if(!cflr)return eulermod(va,phip[cphi]);
	if(cphi==phic)return c?1:0;
	return qpow(cal(va,cflr-1,cphi+1),cphi);
}
inline void init(){
	/*
	 * 初始化 p 进行嵌套 phi 的结果
	 * p 经过 log 层 phi 嵌套变为 1
	 * i 为偶数，phi(i) &amp;lt; i/2
	 * i 为奇数，phi(i) 为偶数
	 */
	phip[0]=P;
	while(phip[phic]!=1){
		phip[phic+1]=phi(phip[phic]);
		phic++;
	}
	//初始化快速幂
	for(int i=0;i&amp;lt;=phic;i++){
		powc1[i][0]=powc2[i][0]=1;
		for(int j=1;j&amp;lt;=(1&amp;lt;&amp;lt;LG);j++)
			powc1[i][j]=eulermod(powc1[i][j-1]*c,phip[i]);
		for(int j=1;j&amp;lt;=(1&amp;lt;&amp;lt;LG);j++)
			powc2[i][j]=eulermod(powc2[i][j-1]*powc1[i][1&amp;lt;&amp;lt;LG],phip[i]); 
	}
}
namespace segt{
	struct node{
		ll sum,mnfl;//和,区间最少嵌套次数
	}t[MXN&amp;lt;&amp;lt;2];
#define ls (p&amp;lt;&amp;lt;1)
#define rs (p&amp;lt;&amp;lt;1|1)
	inline void pushu(ll p){
		t[p].sum=qmod(t[ls].sum+t[rs].sum,P);
		t[p].mnfl=min(t[ls].mnfl,t[rs].mnfl);
	}
	void build(ll p,ll l,ll r){
		if(l==r){
			t[p].mnfl=0;
			t[p].sum=arr[l];
			return;
		}
		ll mid=(l+r)&amp;gt;&amp;gt;1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushu(p);
	}
	void upd(ll p,ll l,ll r,ll ul,ll ur){
		if(l==r){
			t[p].sum=qmod(cal(arr[l],++t[p].mnfl,0),P);
			return;
		}
		//mnfl&amp;gt;phic就不用更新了
		//注意边界
		ll mid=(l+r)&amp;gt;&amp;gt;1;
		if(ul&amp;lt;=mid &amp;amp;&amp;amp; t[ls].mnfl&amp;lt;=phic)upd(ls,l,mid,ul,ur);
		if(ur&amp;gt;mid &amp;amp;&amp;amp; t[rs].mnfl&amp;lt;=phic)upd(rs,mid+1,r,ul,ur);
		pushu(p);
	}
	ll que(ll p,ll l,ll r,ll ql,ll qr){
		if(ql&amp;lt;=l &amp;amp;&amp;amp; r&amp;lt;=qr)return t[p].sum;
		ll mid=(l+r)&amp;gt;&amp;gt;1,res=0;
		if(ql&amp;lt;=mid)res=que(ls,l,mid,ql,qr);
		if(qr&amp;gt;mid)res=qmod(res+que(rs,mid+1,r,ql,qr),P);
		return res;
	}
}
int main(){
	scanf(&quot;%lld%lld%lld%lld&quot;,&amp;amp;n,&amp;amp;m,&amp;amp;P,&amp;amp;c);
	for(int i=1;i&amp;lt;=n;i++)scanf(&quot;%lld&quot;,arr+i);
	init();segt::build(1,1,n);
	while(m--){
		ll op,l,r;
		scanf(&quot;%lld%lld%lld&quot;,&amp;amp;op,&amp;amp;l,&amp;amp;r);
		if(op)printf(&quot;%lld\n&quot;,segt::que(1,1,n,l,r));
		else segt::upd(1,1,n,l,r);
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;实现细节&quot;&gt;实现细节&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;代码中，我用 &lt;code&gt;phip[i]&lt;/code&gt; 预处理出了 $\varphi^i(p)$ 的值，其中 &lt;code&gt;phic+1&lt;/code&gt; 则对应前文中 $z$ 的定义。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;我还定义了一个函数 &lt;code&gt;eulermod(x,y)&lt;/code&gt;，表示以欧拉定理中的形式处理 x 模 y 的结果，这样我们就可以在计算欧拉函数的过程中免于讨论的烦恼。
    &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;inline ll eulermod(ll x,ll mod){return x&amp;lt;=mod?x:(x%mod+mod);}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可能有人会问：在计算 $f^x(a_i)\ (eulermod\ p)$ 时，会不会出现本来 $f^x(a_i)$ 是大于等于 p 的， 但是由于计算 $f^{x-1}(a_i)$ 函数返回的结果是 $eulermod\ \varphi(p)$ 意义下的，从而导致算出来的 $f((f^{x-1}(a_i)\ (eulermod\ p)) &amp;lt; p$？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;答案是否定的，证明如下：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;若 $c=0/1$，显然 $f^x(a_i)&amp;lt;p$，没有上述问题&lt;/li&gt;
      &lt;li&gt;若 $c\ge 2$：
        &lt;ul&gt;
          &lt;li&gt;如果 $f^{x-1}(a_i)&amp;lt; \varphi(p)$：则 $f^{x-1}(a_i)=f^{x-1}(a_i)\ (eulermod\ p)$ 没有上述问题&lt;/li&gt;
          &lt;li&gt;如果 $f^{x-1}(a_i)\ge \varphi(p)$：则因为 $\log_2p \le \varphi(p)$，所以 $p \le f(\varphi (p)) \le f((f^{x-1}(a_i)\ (eulermod\ p))$，上述问题同样不存在，证毕。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 20 Feb 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/02/20/%E9%A2%98%E8%A7%A3-P3747-%E7%9B%B8%E9%80%A2%E6%98%AF%E9%97%AE%E5%80%99/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/02/20/%E9%A2%98%E8%A7%A3-P3747-%E7%9B%B8%E9%80%A2%E6%98%AF%E9%97%AE%E5%80%99/</guid>
        
        <category>算法</category>
        
        <category>题解</category>
        
        <category>数论</category>
        
        <category>线段树</category>
        
        
      </item>
    
      <item>
        <title>【题解】洛谷二月月赛div2</title>
        <description>&lt;p&gt;这次月赛感觉考的海星，估计是 WC 爆炸时失去的 RP 又回来了吧。前一个小时多点把 abc 都切了，后面都没骗到分（&lt;/p&gt;

&lt;h2 id=&quot;t1-mdoi-r4fun&quot;&gt;T1 『MdOI R4』Fun&lt;/h2&gt;
&lt;p&gt;傻子题，直接模拟即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;ll n,m,k;
ll arr[MXN];
inline void solve(){
	//codes
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;k;
	for(int i=1;i&amp;lt;=n;i++)
		cin&amp;gt;&amp;gt;arr[i];
	ll cnt=0;
	for(int i=1;i&amp;lt;=n;i++){
		ll tmp;
		cin&amp;gt;&amp;gt;tmp;
		cnt+=tmp&amp;amp;arr[i];
	}
	cout&amp;lt;&amp;lt;n-cnt+min(cnt,m);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;t2-mdoi-r4color&quot;&gt;T2 『MdOI R4』Color&lt;/h2&gt;

&lt;p&gt;我写的是一个 dp，常数超大且细节巨多，不知道其他人咋写的，个个 40ms。我的做法思路倒是很好想：&lt;/p&gt;

&lt;p&gt;\(dp[i][j][k]\ (j,k\in[0,3])\)
表示染色到 i 这列时&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;j=0 时，表示 (1,i) 没有被覆盖&lt;/li&gt;
  &lt;li&gt;j=1 时，表示 (1,i) 和 (1,i-1) 被一起盖住了&lt;/li&gt;
  &lt;li&gt;j=2 时，表示 (1,i) 和 (1,i+1) 被一起盖住了&lt;/li&gt;
  &lt;li&gt;j=3 时，表示 (1,i) 和 (2,i) 被一起该住了
k 代表的意义也类似，不过k表示的是 (2,i) 的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;转移极度繁琐，但是有很多都是复制粘贴的，详见代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;ll n,m,k;
ll arr[3][MXN];
char str[3][MXN];
bool dp[MXN][4][4];
inline void solve(){
    //codes
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;(str[1]+1)&amp;gt;&amp;gt;(str[2]+1);
	for(int i=1;i&amp;lt;=2;i++)
		for(int j=1;j&amp;lt;=n;j++)
			arr[i][j]=str[i][j]-'0';
	/*
	 * 0=空
	 * 1=向左
	 * 2=向右
	 * 3=向上/下
	 */
	for(int i=0;i&amp;lt;=n;i++)
		for(int j=0;j&amp;lt;4;j++)
			for(int k=0;k&amp;lt;4;k++)
				dp[i][j][k]=0;
	dp[0][3][3]=1;
	for(int i=0;i&amp;lt;n;i++)
		for(int j=0;j&amp;lt;4;j++)
			for(int k=0;k&amp;lt;4;k++){
				if(!dp[i][j][k])continue;

				if((arr[1][i+1]&amp;amp;arr[2][i+1])==0 &amp;amp;&amp;amp; j!=2 &amp;amp;&amp;amp; k!=2)
					dp[i+1][3][3]=1;

				
				for(int x=0;x&amp;lt;3;x++){
					if(x==0){
						if(j==2)continue;
						if(arr[1][i+1])continue;
					}
					if(x==1){
						if(j!=2)continue;
						if(arr[1][i+1]&amp;amp;arr[1][i])continue;
					}
					if(x==2){
						if(i+1==n)continue;
						if(arr[1][i+1]&amp;amp;arr[1][i+2])continue;
					}
					for(int y=0;y&amp;lt;3;y++){
						if(y==0){
							if(k==2)continue;
							if(arr[2][i+1])continue;
						}
						if(y==1){
							if(k!=2)continue;
							if(arr[2][i+1]&amp;amp;arr[2][i])continue;
						}
						if(y==2){
							if(i+1==n)continue;
							if(arr[2][i+1]&amp;amp;arr[2][i+2])continue;
						}
						dp[i+1][x][y]=1;
					}
				}
			}
	for(int j=0;j&amp;lt;4;j++)
		for(int k=0;k&amp;lt;4;k++)
			if(dp[n][j][k]){
				cout&amp;lt;&amp;lt;&quot;RP&quot;&amp;lt;&amp;lt;endl;
				return;
			}
	cout&amp;lt;&amp;lt;&quot;++&quot;&amp;lt;&amp;lt;endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;t3-mdoi-r4kotori&quot;&gt;T3 『MdOI R4』Kotori&lt;/h2&gt;

&lt;p&gt;我们需要维护每个选手是否有可能晋级到第 i 轮比赛，可以一轮一轮的递推。&lt;/p&gt;

&lt;p&gt;以&lt;strong&gt;第三轮比赛&lt;/strong&gt;为例：&lt;/p&gt;

&lt;p&gt;当前，每四名选手都决出了一个冠军。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不妨设 1 号选手可以晋级到第三轮比赛，我们需要看他可不可能再晋级一轮。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;1 号选手本场比赛需要与前两轮中 5-8 号选手中决出的冠军对阵，所以我们希望这个冠军越&lt;strong&gt;弱&lt;/strong&gt;越好（这样 1 号选手就更可能获胜）&lt;/li&gt;
  &lt;li&gt;即求 5-8 号选手中，可以晋级到第三轮的最弱的选手&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上面的方法暴力就可以得到 $O(N^2\log(N))$ 的算法。但是我们发现 5-8 号中可能的最弱冠军会被多次调用（在递推 1-4 号的时候都会用到），所以我们可以开一个 mn 数组，并把 5-8 号中可能的最弱冠军存到 mn[5] 上即可，复杂度 $N\log(N)$。&lt;/p&gt;

&lt;p&gt;代码实现很短：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;
typedef long long ll;
const ll INF=1e18;
const ll MXN=3e5;
ll n,m,k;
ll arr[MXN],mn[MXN],tmp[MXN];
void cal(ll lv){
	ll t=1&amp;lt;&amp;lt;lv;
	ll tt=t&amp;lt;&amp;lt;1;
	ll ft=~(t-1);
	ll ft1=~(tt-1);

	for(int i=0;i&amp;lt;n;i+=t)tmp[i]=INF;
	for(int i=0;i&amp;lt;n;i++){
		ll ol=(i&amp;amp;ft)^t;
		ll cl1=i&amp;amp;ft1;
		if(arr[i]+m&amp;lt;mn[ol])
			arr[i]=INF;
		tmp[cl1]=min(tmp[cl1],arr[i]);
	}
	for(int i=0;i&amp;lt;n;i+=tt)
		mn[i]=tmp[i];
}
inline void solve(){
	cin&amp;gt;&amp;gt;k&amp;gt;&amp;gt;m;
	n=1&amp;lt;&amp;lt;k;
	for(int i=0;i&amp;lt;n;i++){
		cin&amp;gt;&amp;gt;arr[i];
		mn[i]=arr[i];
	}
	for(int i=0;i&amp;lt;k;i++){
		cal(i);
        if(arr[0]==INF){
            cout&amp;lt;&amp;lt;&quot;Yoshino\n&quot;;
            return;
        }
    }
	cout&amp;lt;&amp;lt;&quot;Kotori\n&quot;;
}
int main(){
	ll tq;cin&amp;gt;&amp;gt;tq;
	while(tq--)solve();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 09 Feb 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/02/09/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7%E4%BA%8C%E6%9C%88%E6%9C%88%E8%B5%9Bdiv2/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/02/09/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7%E4%BA%8C%E6%9C%88%E6%9C%88%E8%B5%9Bdiv2/</guid>
        
        <category>算法</category>
        
        <category>题解</category>
        
        
      </item>
    
      <item>
        <title>【题解】P7287魔法</title>
        <description>&lt;p&gt;题目在此：&lt;a href=&quot;https://www.luogu.com.cn/problem/P7287&quot;&gt;P7287&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;所有的 1 操作一定在所有的 2 操作之前进行&lt;/li&gt;
  &lt;li&gt;每个 1 操作的范围一定是 [1,n]&lt;/li&gt;
  &lt;li&gt;每次 2 操作都是对当前序列的最大字段和那个区间进行的。&lt;/li&gt;
  &lt;li&gt;最终选的区间是最终序列的最大子段和&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1，2，4 都很显然，3 结论可感性理解&lt;del&gt;（这个野鸡博主不会证）&lt;/del&gt;：&lt;/p&gt;

&lt;p&gt;如果每次都选那个最大子段和进行操作，那得到的结果一定是最优的。
否则一旦在操作过程中有操作的区间不是最大子段和区间的话，在进行同样次操作之后的结果是不优的。&lt;/p&gt;

&lt;h2 id=&quot;算法&quot;&gt;算法&lt;/h2&gt;

&lt;p&gt;现在，我们只需要知道 1 操作以及 2 操作的次数，就能算出最终数列的最大最大字段和。接着观察发现2操作的次数是不超过\(log(值域)\)次的。&lt;/p&gt;

&lt;p&gt;所以我们只需枚举 2 操作的次数，再二分出 1 操作的次数即可。&lt;/p&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define rd scanf
#define pt printf
#define setp(x) setprecision(x)
#define mem(x,y) memset(x,y,sizeof(x))
#define sz(x) (int)x.size()
#define umn(x,y) x=min(x,y)
#define umx(x,y) x=max(x,y)
typedef long long ll;
typedef unsigned long long ull;
typedef pair&amp;lt;ll,ll&amp;gt; pi;
typedef vector&amp;lt;ll&amp;gt; vi;
typedef vector&amp;lt;pi&amp;gt; vpi;

const double eps=1e-9;
const ll INF=1e18;
const ll P=998244353;
const ll MXN=1e5+5;

inline ll mod(ll x){return x&amp;gt;=P?x-P:x;}
inline ll mul(ll x,ll y){if(x&amp;lt;y)swap(x,y);ll res=0;while(y){if(y&amp;amp;1)res=mod(res+x);x=mod(x&amp;lt;&amp;lt;1);y&amp;gt;&amp;gt;=1;}return res;}
inline ll qpow(ll x,ll y){ll res=1;while(y){if(y&amp;amp;1)res=res*x%P;x=x*x%P;y&amp;gt;&amp;gt;=1;}return res;}
ll gcd(ll x,ll y){return !y?x:gcd(y,x%y);}
inline void pbin(ll x,ll y){for(;~y;y--)cerr&amp;lt;&amp;lt;char('0'+((x&amp;gt;&amp;gt;y)&amp;amp;1));cerr&amp;lt;&amp;lt;endl;}



ll n,a,b,s;
ll arr[MXN];
inline ll cal(ll add){
	ll last=0,ans=0;
	for(int i=1;i&amp;lt;=n;i++){
		last=max(last,0ll)+arr[i]+add;
		umx(ans,last);
	}
	return ans;
}
inline bool chk(ll add,ll pwr){
	ll tmp=cal(add);
	for(int i=0;i&amp;lt;=pwr;i++)
		if((tmp&amp;lt;&amp;lt;i)&amp;gt;=s)return 1;
	return 0;
}


inline void solve(){
    //codes
	cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;s;
	for(int i=1;i&amp;lt;=n;i++)cin&amp;gt;&amp;gt;arr[i];

	ll ans=INF;
	for(int i=0;i&amp;lt;=32;i++){
		ll l=0,r=2e9;
		while(l&amp;lt;r){
			ll mid=(l+r)&amp;gt;&amp;gt;1;
			if(chk(mid,i))r=mid;
			else l=mid+1;
		}
		ans=min(ans,a*l+b*i);
	}
	cout&amp;lt;&amp;lt;ans;
    
}
int main(){
	//freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
	//freopen(&quot;.out&quot;,&quot;w&quot;,stdout);
	ios_base::sync_with_stdio(0);cin.tie(0);
	cout&amp;lt;&amp;lt;setiosflags(ios::fixed);
	srand(time(NULL));

	solve();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 25 Jan 2021 00:00:00 +0800</pubDate>
        <link>http://blog-e.tk/2021/01/25/%E9%A2%98%E8%A7%A3-P7287%E9%AD%94%E6%B3%95/</link>
        <guid isPermaLink="true">http://blog-e.tk/2021/01/25/%E9%A2%98%E8%A7%A3-P7287%E9%AD%94%E6%B3%95/</guid>
        
        <category>算法</category>
        
        <category>题解</category>
        
        
      </item>
    
  </channel>
</rss>
